public class AMS_OSCARTriggerHandler {

	//*************************************
	//************ variables **************
	//*************************************

	class AMSException extends Exception {}
	
	private static ID rtAgencyInvolved = Schema.SObjectType.AMS_Process_Detail__c.getRecordTypeInfosByName().get('Agency Involved').getRecordTypeId();

	//used to identify situations where the LocationType of an SA Agency should not be changed
	public static Boolean keepSALocationTypeFlag = false;

	public static Map<String, String> closedStatusMapping{
		get{
			if(closedStatusMapping == null){
				closedStatusMapping = new Map<String, String>{
					'Closed (Closed)' => 'Closed',
					'Closed_Not Accepted' => 'Closed_ Not Accepted',
					'Closed_Rejected' => 'Closed_Rejected',
					'Closed_Withrawn' => 'Closed_Withdrawn'
				};
			}
			return closedStatusMapping;
		}
		set;
	}

	//*************************************
	//********* context methods ***********
	//*************************************

	public static void handleBeforeUpdate(List<AMS_OSCAR__c> oscars) {
		prepopulateValues();
		AMS_AccreditationContactHelper.mirrorAccrediationContactsFromAccountRole(oscars, (Map<Id,AMS_OSCAR__c>)Trigger.oldMap);
		//create agency regulation objects for Cargo agencies
		handleCargoAgencyRegulations();
		handleChangesProcess(oscars);
        copyDataFromTargetAgency();
		updateOSCARAppointments();
		handleVRProcess();
		checkOwnershipOnProcess(oscars, (Map<Id,AMS_OSCAR__c>)Trigger.oldMap);
	}

	public static void handleBeforeInsert() {
		assignOSCARToRegionalQueues();
		prepopulateValues();
		AMS_AccreditationContactHelper.mirrorAccrediationContactsFromAccountRole((List<AMS_OSCAR__c>)Trigger.New, null);
        copyDataFromTargetAgency();
	}

	public static void handleAfterInsert() {
		updateCaseKPIFields();
	}

	public static void handleAfterUpdate() {

		updateCaseKPIFields();
		updateCaseInfo();
	}

    private static void copyDataFromTargetAgency(){

        List<AMS_Pax_Accreditation_Form__c> onlineAccredsToUpdate = new List<AMS_Pax_Accreditation_Form__c>();

        Set<Id> targetAccountsIds = new Set<Id>();
        Set<Id> oscarOnlineAccredIds = new Set<Id>();
        List<AMS_OSCAR__c> oscarsToProcess = new List<AMS_OSCAR__c>();

        for(AMS_OSCAR__c oscar: (List<AMS_OSCAR__c>)Trigger.New){
            if(oscar.AMS_Target_Agency__c != null && oscar.Type_of_change__c.containsIgnoreCase(AMS_Utils.OWNERSHIP_IATA)){
                AMS_OSCAR__c oldOscar;
                if(Trigger.isUpdate)
                    oldOscar = (AMS_OSCAR__c)Trigger.oldMap.get(oscar.Id);
                //Id oldTarget = oldOscar.AMS_Target_Agency__c;
                //Id currentTarget = oscar.AMS_Target_Agency__c;
                if(Trigger.isInsert || (Trigger.isUpdate && oscar.AMS_Target_Agency__c != oldOscar.AMS_Target_Agency__c)){
                    targetAccountsIds.add(oscar.AMS_Target_Agency__c);
                    oscarOnlineAccredIds.add(oscar.AMS_Online_Accreditation__c);
                    oscarsToProcess.add(oscar);
                }
            }
        }

        if(!oscarsToProcess.isEmpty()){

            Map<Id, Account> targetAccounts = new Map<Id, Account>([SELECT Name, IATACode__c, Company_Type__c, Short_Name__c, TradeName__c, License_Number__c, VAT_Number__c, GDS__c, Operation__c,
                    BillingCountry, BillingStreet, BillingPostalCode, BillingState, BillingCity, IATA_ISO_Country__c, Iso_State__c, ShippingCountry,
                    ShippingStreet, ShippingPostalCode, ShippingState, ShippingCity, Email__c, Website, Phone, Fax, In_a_Airport__c, Abbreviated_name__c, Abbreviated_address__c,
                    Remittance_frequency__c, Solicitation_Flag__c, VAT_Number_2__c, CASS_Number__c, Location_Class__c, Location_Type__c, Mobile__c, Is_your_firm_handling_Dangerous_Goods__c
                    ,IATA_ISO_Billing_State__c, IATA_ISO_Shipping_Country__c, IATA_ISO_Shipping_Country__r.Name, IATA_ISO_Shipping_State__c, IATA_ISO_Shipping_State__r.Name, ISO_State__r.Name FROM Account WHERE Id IN :targetAccountsIds]);


            Map<Id, AMS_Pax_Accreditation_Form__c> onlineAccreditations = new Map<Id, AMS_Pax_Accreditation_Form__c>([SELECT Account_Name__c, IATACode__c, ISSP_AMS_Legal_Status__c, Short_Name__c, Trade_Name__c, ISSP_AMS_License_No__c, ISSP_AMS_VAT_number__c,
                    ISSP_AMS_GDS_with_signed_contract__c, Operation__c, Branch_Office_Country__r.Name, Branch_Office_Street_name_number__c, Branch_Office_Postal_code__c,
                    Billing_State__c, Branch_Office_City__c, ISO_Country__c, IATA_ISO_State__c, Shipping_Country__c, Shipping_Street__c, Shipping_Postal_Code__c,
                    Shipping_State__c, Shipping_City__c, Branch_Office_Email__c, Website__c, Branch_Office_Phone__c, Branch_Office_FAX__c, ISSP_AMS_Premises_located_at_airport__c,
                    Abbreviated_name__c, Abbreviated_address__c, Remittance_frequency__c, Solicitation_Flag__c, VAT_Number_2__c, CASS_Number__c, Location_Class__c, Location_Type__c, Mobile__c, Is_your_firm_handling_Dangerous_Goods__c
                    ,Shipping_ISO_Country__c,Shipping_ISO_State__c, Shipping_ISO_Country__r.Name, Shipping_ISO_State__r.Name, IATA_ISO_State__r.Name
                    FROM AMS_Pax_Accreditation_Form__c
                    WHERE Id IN :oscarOnlineAccredIds]);

            for (AMS_OSCAR__c oscar : oscarsToProcess) {
                onlineAccredsToUpdate.add(AMS_Utils.CopyDataFromAccountToStaging(AMS_UTILS.OWNERSHIP_IATA, targetAccounts.get(oscar.AMS_Target_Agency__c), onlineAccreditations.get(oscar.AMS_Online_Accreditation__c)));
            }

            if(!onlineAccredsToUpdate.isEmpty())
                update onlineAccredsToUpdate;
        }


    }

	//*************************************
	//********** helper methods ***********
	//*************************************
	private static void prepopulateValues() {
		//AMS-1674 - [Agency changes] when "Type of change" include "Location type" the "Change of location type behavior" shoule be pre-populated

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		for(AMS_OSCAR__c oscar : (List<AMS_OSCAR__c>)Trigger.New){
			if(
				oscar.Process__c == AMS_Utils.AGENCYCHANGES
				&& oscar.Type_of_change__c != null
				&& oscar.Change_of_location_type_behavior__c == null
				//&& (Trigger.isInsert || oscar.Type_of_change__c != oldMap.get(oscar.Id).Type_of_change__c)
			){
			    Set<String> tocList = new Set<String>();
			    tocList.addAll(oscar.Type_of_change__c.split(';'));

		        if(tocList.contains(AMS_Utils.LOCATION_TYPE)){
		            oscar.Change_of_location_type_behavior__c = AMS_Utils.CHLOCTYPEBEHAVIOR_STANDARD;
		        }

			}
		}
	}

	private static void assignOSCARToRegionalQueues(){

		List<AMS_OSCAR__c> certificationOscars = new List<AMS_OSCAR__c>();

		for(AMS_OSCAR__c oscar : (List<AMS_OSCAR__c>)Trigger.New)
			if(oscar.RecordTypeId == AMS_Utils.RECTYPE_CERT)
				certificationOscars.add(oscar);

		if(!certificationOscars.isEmpty())
			AMS_OscarCaseTriggerHelper.assignOscarToRegionQueue(certificationOscars);
	}

	public static void handleChangesProcess(List<AMS_OSCAR__c> oscars) {

		//do Not run minor changes on agency changes trigger????
		AMS_AccountTriggerHandler.processMinorChangesValidationFlag = false;
		AMS_AccountTriggerHandler.minorChangesComingFromOSCAR = true;
		for(AMS_OSCAR__c oscar : oscars)
			if(oscar.Type_of_change__c!=null && oscar.Type_of_change__c.contains(AMS_Utils.REMOVALTRADENAME))
				AMS_AccountTriggerHandler.comingFromOSCARforRemoveTradeName = true;
		Id changeRT = Schema.AMS_OSCAR__c.sObjectType.getDescribe().getRecordTypeInfosByName().get('CHANGE').getRecordTypeId();
		List<AMS_OSCAR__c> oscarsToValidate = filterOSCARbyRT(changeRT, oscars);

		if (oscarsToValidate.size() > 0) {

			List<Map<String, String>> configs = AMS_AgencyChangesConfigHelper.getAgencyChangesConfigData();

			List<AMS_OSCAR__c> oscarsToProcess = getAgencyChangeOSCARSToProcess(oscarsToValidate);

			if (validateTypeOfChange(oscarsToValidate, configs) && oscarsToProcess.size() > 0 )
				processAgencyChanges(oscarsToProcess, configs);
		}
	}

	public static boolean validateTypeOfChange(List<AMS_OSCAR__c> oscars, List<Map<String, String>> configs) {

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		List<String> oscarStepsApiName = getOSCARStepsApiName();

		for (AMS_OSCAR__c oscar : oscars) {

			if (oscar.Type_of_change__c <> oldMap.get(oscar.Id).Type_of_change__c && oldMap.get(oscar.Id).STEP6__c == AMS_Utils.PASSED)
				{
					oscar.addError('Type of Change cannot be changed after Sanity Check is passed.');
					return false;
				}



			if (oscar.Type_of_change__c <> oldMap.get(oscar.Id).Type_of_change__c || oldMap.get(oscar.Id).STEP6__c <> AMS_Utils.PASSED && oscar.STEP6__c == AMS_Utils.PASSED) {
				AMS_Utils.AgChangesConfig config = AMS_AgencyChangesConfigHelper.getSelectedTypeOfChangeCombinationConfig(oscar, configs);
				if (config != null && config.config != null) {
					List<String> notApplicableSteps = AMS_AgencyChangesConfigHelper.getNotApplicableSteps(config.config);
					if (notApplicableSteps != null)
						AMS_AgencyChangesConfigHelper.setNotApplicableSteps(notApplicableSteps, oscarStepsApiName, oscar);
				}
				else{
					return false;
				}
			}
	}

		return true;
		
	}

	//get only the Agency Change OSCARs that need to be processed
	private static List<AMS_OSCAR__c> getAgencyChangeOSCARSToProcess(List<AMS_OSCAR__c> oscars) {

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		ID changeRT = Schema.SObjectType.AMS_OSCAR__c.getRecordTypeInfosByName().get('CHANGE').getRecordTypeId();

		List<AMS_OSCAR__c> changeOscars = new List<AMS_OSCAR__c>();
		for (AMS_OSCAR__c oscar : oscars) {
			if (oscar.recordTypeID == changeRT) {
				AMS_OSCAR__c oldOSCAR = oldMap.get(oscar.Id);
				if ((oldOSCAR.STEP6__c <> AMS_Utils.PASSED && oscar.STEP6__c == AMS_Utils.PASSED) || (oldOSCAR.RPM_Approval__c <> AMS_Utils.AUTH_APPROVAL && oscar.RPM_Approval__c == AMS_Utils.AUTH_APPROVAL) || (oldOSCAR.STEP4__c <> AMS_Utils.PASSED && oscar.STEP4__c == AMS_Utils.PASSED) || (!oldOSCAR.Apply_Penalty_Fee__c && oscar.Apply_Penalty_Fee__c))
					changeOscars.add(oscar);

			}
		}

		return changeOscars;
	}

	public static void processAgencyChanges(List<AMS_OSCAR__c> oscars, List<Map<String, String>> configs) {

		boolean isSanityCheck = false;

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		//map that will be used to verify ownership consistency between a list of agencies
		Map<Id, Set<Id>> accsToCompareOwnership = new Map<Id, Set<Id>>();

		//map that given an agency will give us the id of its terminated child accounts
		Map<Id, Set<Id>> agencyTerminatedChildAgencies = new Map<Id, Set<Id>>();

		//this Container will store all change codes that need to be created
		List<AMS_Utils.Container> changesContainer = new List<AMS_Utils.Container>();

		//store all the updates to be made on account as consequence of migration of data from staging area to master data

		Map<Id,AMS_ChangeCodesHelper.ObjectChangesStruct> accountsToUpdate = new Map<Id,AMS_ChangeCodesHelper.ObjectChangesStruct>();

		// Account Fields Information
		Map<String, Schema.SObjectField>  acctFieldsMap= Schema.SObjectType.Account.fields.getMap();

		//this structure contains all the hierarchy relationships that need to be inserted/updated/deleted
		List<AMS_HierarchyHelper.HierarchyStruct> hierarchyChanges = new List<AMS_HierarchyHelper.HierarchyStruct>();

		Set<Id> accountIds = new Set<Id>();
		Set<Id> oscarIds = new Set<Id>();
		Set<Id> oscarOnlineAccredIds = new Set<Id>();

		Map<Id, List<AMS_Process_Detail__c>> processDetailPerOSCAR = new Map<Id, List<AMS_Process_Detail__c>>();

		for (AMS_OSCAR__c oscar : oscars) {
			accountIds.add(oscar.Account__c);
			accountIds.add(oscar.AMS_Target_Agency__c);
			oscarIds.add(oscar.Id);
			oscarOnlineAccredIds.add(oscar.AMS_Online_Accreditation__c);
		}

		//query the the Process Detail object for all the agencies that are being bought
		//DTULLO: Added Check on Record Type
		List<AMS_Process_Detail__c> allProcessDetails = new List<AMS_Process_Detail__c>([SELECT Id, Account__c, OSCAR__c, Account__r.Status__c, RecordType.Developername FROM AMS_Process_Detail__c WHERE OSCAR__c IN :oscarIds and RecordType.Developername = 'Agency_Involved']);

		for (AMS_Process_Detail__c pd : allProcessDetails) {
			//TERMINATED AGENCIES IGNORED
			if(pd.Account__c != null && pd.Account__r.Status__c != AMS_Utils.ACC_S0_TERMINATED){
				if (processDetailPerOSCAR.get(pd.OSCAR__c) == null)
					processDetailPerOSCAR.put(pd.OSCAR__c, new List<AMS_Process_Detail__c> {pd});
				else
					processDetailPerOSCAR.get(pd.OSCAR__c).add(pd);
			}

		}

		//need to get all the hierarchy relationships for the account related to each OSCAR
		Map<Id, List<AMS_Agencies_relationhip__c>> accountHierarchyRelationships = AMS_HierarchyHelper.getAccountsHierarchies(accountIds);

		for (List<AMS_Agencies_relationhip__c> hierarchyRelations : accountHierarchyRelationships.values()) {
			for (AMS_Agencies_relationhip__c relationship : hierarchyRelations) {

				accountIds.add(relationship.Parent_Account__c);
				accountIds.add(relationship.Child_Account__c);

				if(relationship.Child_Account__r.Status__c == AMS_Utils.ACC_S0_TERMINATED){
					if(!agencyTerminatedChildAgencies.containsKey(relationship.Parent_Account__c))
						agencyTerminatedChildAgencies.put(relationship.Parent_Account__c, new Set<Id>());

					agencyTerminatedChildAgencies.get(relationship.Parent_Account__c).add(relationship.Child_Account__c);

				}

			}
		}

		//need to find the list of SAs directly related to the each account related to an OSCAR
		Map<Id, Set<Id>> agencyToSAs = new Map<Id, Set<Id>>();

		for(AMS_OSCAR__c oscar : oscars){
			for (List<AMS_Agencies_relationhip__c> hierarchyRelations : accountHierarchyRelationships.values()) {
				for (AMS_Agencies_relationhip__c relationship : hierarchyRelations) {

					if(relationship.Parent_Account__c == oscar.Account__c &&
						relationship.Child_Account__r.Location_Type__c==AMS_Utils.SA &&
						relationship.Child_Account__r.Status__c!=AMS_Utils.ACC_S0_TERMINATED){
						if(agencyToSAs.get(oscar.Account__c)==null)
							agencyToSAs.put(oscar.Account__c, new Set<Id>());
						agencyToSAs.get(oscar.Account__c).add(relationship.Child_Account__c);
                        system.debug(LoggingLevel.ERROR,'[LF]: Agenzia '+oscar.Account__c+' ha SA '+relationship.Child_Account__c);
					}

				}
			}
		}
		system.debug(LoggingLevel.ERROR,'[LF]: FINE CALCOLO SA');

		//get the active changecode for each account
		List<Agency_Applied_Change_code__c> activeChangeCodes =
		    new List<Agency_Applied_Change_code__c>([SELECT Id, Account__c, Reason_Code__c, Reason_Description__c, Bulletin_Information__c FROM Agency_Applied_Change_code__c WHERE Account__c IN :accountIds AND Active__c = true]);

		//map accountId -> active change code
		Map<Id, Agency_Applied_Change_code__c> accountsChangeCode = new Map<Id, Agency_Applied_Change_code__c>();
		for (Id accId : accountIds) {
			for (Agency_Applied_Change_code__c changeCode : activeChangeCodes)
				if (changeCode.Account__c == accId)
					accountsChangeCode.put(accId, changeCode);
		}



		Map<Id, Account> accounts = getAccounts(accountIds);

		//<Account Id, Current Location Type>
		// Get the Accounts location type in the beggining before its changed (as in the case of a change of Ownership to non IATA
		// )
		Map<Id, AMS_HierarchyHelper.AccountStruct> accountStructPerAcct = getAccountsInfoBeforeChanges(accounts);

		Map<Id, AMS_Pax_Accreditation_Form__c> onlineAccreditations = getAccreditations(oscarOnlineAccredIds);

		//Here we will save the accounts that will suffer ownership changes
		Map<Id, Set<Id>> accountsAffectedPerOnlineAccreditation = new Map<Id, Set<Id>>();

		AMS_Utils.AgChangesConfig config;
		//configuration used when we need to apply a different change Code on agencies in Process Detail
		AMS_Utils.AgChangesConfig config2;
		//configuration used when we need to apply a different change Code for change of location to SAs
		AMS_Utils.AgChangesConfig config3;

		system.debug('processAgencyChanges() --> oscars = ' + oscars);

		boolean needValidationsOnStagingArea = false;
		Set<ID> stagingAreaIDs = new Set<ID>();
		Map<ID,AMS_Pax_Accreditation_Form__c> stagingAreas = new Map<ID,AMS_Pax_Accreditation_Form__c>();
		for (AMS_OSCAR__c oscar : oscars){
			if(oscar.AMS_Online_Accreditation__c!=null)
				stagingAreaIDs.add(oscar.AMS_Online_Accreditation__c);
			if(oscar.Type_of_change__c!=null && oscar.Type_of_change__c.contains(AMS_Utils.REMOVALTRADENAME))
				needValidationsOnStagingArea = true;
		}

		if(needValidationsOnStagingArea){
			stagingAreas = new Map<ID,AMS_Pax_Accreditation_Form__c>([SELECT Id, Trade_Name__c FROM AMS_Pax_Accreditation_Form__c WHERE ID IN :stagingAreaIDs]);
		}


		for (AMS_OSCAR__c oscar : oscars) {

			AMS_OSCAR__c oldOSCAR = oldMap.get(oscar.Id);

			system.debug('processAgencyChanges() --> oscar = ' + oscar.Type_of_change__c + ' - oscar.staging = ' + oscar.AMS_Online_Accreditation__c);
			if (oscar.Type_of_change__c != null) {

				//Separate types of changes in 2 groups:
				//types of changes to be applied on all the hierarchy agencies defined in the Process Detail plus the Agency where the OSCAR was opened
				String cascadingTOCs = AMS_AgencyChangesConfigHelper.getPropagatableTypesOfChange(oscar.Type_of_change__c);

				//types of changes only to be applied on the Agency where the OSCAR was opened
				String nonCascadingTOCs =  AMS_AgencyChangesConfigHelper.getNonPropagatableTypesOfChange(oscar.Type_of_change__c);

				System.debug('AGENCY CHANGES: Propagate changes selected: ' + cascadingTOCs);
				System.debug('AGENCY CHANGES: Non Propagate changes selected: ' + nonCascadingTOCs);

				config = AMS_AgencyChangesConfigHelper.getSelectedTypeOfChangeCombinationConfig(oscar, configs);

				if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() > 0)
					config2 = AMS_AgencyChangesConfigHelper.getTypeOfChangeCombinationConfig(cascadingTOCs, oscar, configs);

				List<AMS_Process_Detail__c> pds = processDetailPerOSCAR.get(oscar.Id);

				Set<Id> agenciesAffected = new Set<Id>();

				if (pds != null)
					for (AMS_Process_Detail__c pd : pds)
						agenciesAffected.add(pd.Account__c);

				AMS_Pax_Accreditation_Form__c oscarOnlineAccreditation = onlineAccreditations.get(oscar.AMS_Online_Accreditation__c);

				Id hierarchyHO = AMS_HierarchyHelper.getHierarchyHO(accountHierarchyRelationships.get(oscar.Account__c));

				Set<String> tocList = new Set<String>();
				tocList.addAll(oscar.Type_of_change__c.split(';'));


				//this is used by change of location: create a list of SAs involved in the change and SA not involved in the change
				boolean changeContainsLocation = (nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION) || nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION_TYPE));
				String changeOfLocation = '';
				if (nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION))
					changeOfLocation = AMS_Utils.LOCATION;
				else if (nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION_TYPE))
					changeOfLocation = AMS_Utils.LOCATION_INSPECTION;

				Set<Id> SAsInvolved = new Set<Id>();
				Set<Id> SAsNotInvolved = new Set<Id>();
				Set<Id> allSAs = new Set<Id>();

				if(changeContainsLocation && agencyToSAs.get(oscar.Account__c)!=null){
					config3 = AMS_AgencyChangesConfigHelper.getTypeOfChangeCombinationConfig(changeOfLocation, oscar, configs);

					for(Id sa : agencyToSAs.get(oscar.Account__c)){
						boolean found = false;
						for(Id ag : agenciesAffected){
							if(sa==ag){
								SAsInvolved.add(sa);
								found = true;
								break;
							}
						}
						if(!found)
							SAsNotInvolved.add(sa);
					}
					system.debug(LoggingLevel.ERROR,'[LF]: SAS affected: '+SAsInvolved);
					system.debug(LoggingLevel.ERROR,'[LF]: SAS NOT affected: '+SAsNotInvolved);
				}
				if (oldOSCAR.STEP6__c <> AMS_Utils.PASSED && oscar.STEP6__c == AMS_Utils.PASSED) {

					isSanityCheck = true;

					if(!performOscarValidations(toclist, agenciesAffected, oscar, accounts, accountHierarchyRelationships, stagingAreas))
						return;
					oscar.First_Step_Completed__c = true;

					//Location Type will always be selected as a single change.
					if (nonCascadingTOCs.length() > 0 && nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION_TYPE)) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing change of location type in sanity checks');

                        Set<Id> accAffected;
                        //In this situation we only need to create change code for the oscar account
                        if(oscar.Change_of_location_type_behavior__c == AMS_Utils.CHLOCTYPEBEHAVIOR_NOSWAP)
                            accAffected = new Set<Id> {oscar.Account__c};
                        else{ //default swap with parent, create change code for both accounts involved in the swap
                            Id oscarAccountParent = accounts.get(oscar.Account__c).ParentId;
                            accAffected = new Set<Id> {oscar.Account__c, oscarAccountParent};
                            //need to save this parent in hierarchy account selection, because after this operation it will become a child
                            //and we need to keep track of it for the approval process
                            if( pds!= null && pds.size() > 0)
                                throw new AMSException('Change of Location Type processes should not have any account selected in the Hierarchy Account Selection');
							
							//DTULLO: Added Record Type
                            AMS_Process_Detail__c parentAccount = new AMS_Process_Detail__c(Oscar__c = oscar.Id, Account__c = oscarAccountParent,  RecordTypeId = rtAgencyInvolved);
                            insert parentAccount;

                        }


                        changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, accAffected));
                        accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, accAffected, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
					}
					// here there are several possible cases:
					else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() > 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing both cascade and not cascade changes in sanity checks');
						Set<Id> agenciesWithSingleCode = agenciesAffected.clone(); // normally this list includes all the agencies listed in the hierarchy account selection
						Set<Id> agenciesWithMultipleCode = new Set<Id> {oscar.Account__c}; // normally only the main agency is affected by all the changes

						// in case of change which includes location, the SAs should be affected  by the change of location so:
						if(changeContainsLocation  && agencyToSAs.get(oscar.Account__c)!=null){
							agenciesWithSingleCode.removeAll(SAsInvolved); // the SAs which are also listed in the hierarchy account selection should not receive a partial change
							agenciesWithMultipleCode.addAll(SAsInvolved); // the SAs which are also listed in the hierarchy account selection will be affected by the complete change
							// the SAs which are not listed in the hierarchy account selection will be affected by change of location only!
						}

						system.debug(LoggingLevel.ERROR, '[LF]: Main '+oscar.Account__c);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesAffected '+agenciesAffected);
						system.debug(LoggingLevel.ERROR, '[LF]: SAsInvolved '+SAsInvolved);
                        system.debug(LoggingLevel.ERROR, '[LF]: SAsNotInvolved '+SAsNotInvolved);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesWithMultipleCode '+agenciesWithMultipleCode);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesWithSingleCode '+agenciesWithSingleCode);

						if(!agenciesWithSingleCode.isEmpty())
						{
							// Apply cascade + no cascade changes: change code + data migration
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesWithSingleCode, cascadingTOCs, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config2, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, agenciesWithSingleCode));
						}
						
						if(!agenciesWithMultipleCode.isEmpty())
						{
							// Apply cascade + no cascade changes: change code + data migration
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesWithMultipleCode, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, agenciesWithMultipleCode));
						}
						

						// Apply change of location to children SAs not explicitly involved in the change
						if(SAsNotInvolved.size()>0){
							//change code generated only for the agencies not affected by any other change
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, SAsNotInvolved, changeOfLocation, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config3, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, SAsNotInvolved));
						}

					} else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() == 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing not cascade changes in sanity checks');
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, new Set<Id> {oscar.Account__c}));
						accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, new Set<Id> {oscar.Account__c}, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));

						// in case of location (for the moment is 100% but only God knows what will happen in the future)
						// I'll apply the change and generate a CHL also to the SAs
						if(changeContainsLocation  && agencyToSAs.get(oscar.Account__c)!=null){
								//We'll apply CHL to all dependent SAs either involved or not involved
								allSAs.addAll(SAsInvolved);
								allSAs.addAll(SAsNotInvolved);
								changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, allSAs));
								accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, allSAs, changeOfLocation, accounts, oscarOnlineAccreditation));
						}

					} else if (nonCascadingTOCs.length() == 0 && cascadingTOCs.length() > 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing cascade changes in sanity checks');
						agenciesAffected.add(oscar.Account__c);
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.SANITYCHECK, agenciesAffected));
						accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesAffected, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
						// change of location is not affecting this scenario
					}

					agenciesAffected.add(oscar.Account__c);

					Boolean isChangeOwnershipToIATA = tocList.contains(AMS_Utils.OWNERSHIP_IATA) ? true : false;
					//All terminated agencies that would be left without parent MUST be automatically migrated, thus following their parents
					//Exception to the above rule is when we have change of ownership to IATA, where BRs will be left as standalone
					Set<Id> agenciesToMigrate = AMS_HierarchyHelper.addTerminatedDescendants(agenciesAffected, agencyTerminatedChildAgencies, isChangeOwnershipToIATA, accounts);
					system.debug('AgenciesToMigrateHierarchy: ' + agenciesToMigrate);
					system.debug('AgenciesToMigrateData: ' + agenciesAffected);

					AMS_HierarchyHelper.HierarchyStruct hs = processHierarchyChanges(oscar, accounts, accountHierarchyRelationships, agenciesToMigrate);

					hierarchyChanges.add(hs);

					//check if ownership needs to be copied from online form to Accounts
					if (AMS_Utils.ownershipIsToBeMigrated(oscar.Type_of_change__c)){
						accountsAffectedPerOnlineAccreditation.put(oscar.AMS_Online_Accreditation__c, agenciesAffected);

						//fill map to check ownership alignment in hierarchy
						if(cascadingTOCs.contains(AMS_Utils.OWNERSHIP_IATA)){
							//the target agency owners will be compared with the agency owners we are trying to migrate to the target agency hierarchy
							Set<Id> agsToCompareOwner = new Set<Id>(agenciesAffected);
							agsToCompareOwner.add(oscar.AMS_Target_Agency__c);
							accsToCompareOwnership.put(oscar.Id, agsToCompareOwner);
						}

					}

					if (onlineAccreditations.get(oscar.AMS_Online_Accreditation__c).Branch_Office_Country__r.Due_diligence_mandatory__c && oscar.STEP17__c != AMS_Utils.NOT_APPLICABLE) {

						if(accounts.get(oscar.Account__c).Due_Diligence_Status__c == AMS_Utils.IN_PROGRESS) oscar.STEP17__c = AMS_Utils.IN_PROGRESS;
						else{
							String dlResult = AMS_OSCAR_Webservice.createAMLCaseWithNoOscarUpdate(oscar);
							if (dlResult.startsWith('ERROR')) oscar.addError(dlResult);
							else accounts.get(oscar.Account__c).Due_Diligence_Status__c = AMS_Utils.IN_PROGRESS;
						}
					}					

				} else if (oldOSCAR.RPM_Approval__c <> AMS_Utils.AUTH_APPROVAL && oscar.RPM_Approval__c == AMS_Utils.AUTH_APPROVAL) {


					//Location Type will always be selected as a single change.
					if (nonCascadingTOCs.length() > 0 && nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION_TYPE)) {
						System.debug('AGENCY CHANGES: Processing Location Type Change Codes on approval.');

                        Set<Id> accAffected;
                        //In this situation we only need to create change code for the oscar account
                        if(oscar.Change_of_location_type_behavior__c == AMS_Utils.CHLOCTYPEBEHAVIOR_NOSWAP)
                            accAffected = new Set<Id> {oscar.Account__c};
                        else{ //default swap with parent, create change code for both accounts involved in the swap
                            if(pds == null || (pds != null && pds.size() != 1))
                                throw new AMSException('Something went wrong! The Hierarchy Account selection for Change of Location Type must have a single entry for this Oscar. Please contact your administrator.');

                            accAffected = new Set<Id> {oscar.Account__c, pds.get(0).Account__c};
                        }

                        changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.APPROVAL, accAffected));
                        accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, accAffected, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
					}
					//need to apply two different Sets of Change Codes. One for Oscar Account and other for process details
					// here there are several possible cases:
					else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() > 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing both cascade and not cascade changes on approval');
						Set<Id> agenciesWithSingleCode = agenciesAffected.clone(); // normally this list includes all the agencies listed in the hierarchy account selection
						Set<Id> agenciesWithMultipleCode = new Set<Id> {oscar.Account__c}; // normally only the main agency is affected by all the changes

						// in case of change which includes location, the SAs should be affected  by the change of location so:
						if(changeContainsLocation  && agencyToSAs.get(oscar.Account__c)!=null){
							agenciesWithSingleCode.removeAll(SAsInvolved); // the SAs which are also listed in the hierarchy account selection should not receive a partial change
							agenciesWithMultipleCode.addAll(SAsInvolved); // the SAs which are also listed in the hierarchy account selection will be affected by the complete change
							// the SAs which are not listed in the hierarchy account selection will be affected by change of location only!
						}

						system.debug(LoggingLevel.ERROR, '[LF]: Main '+oscar.Account__c);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesAffected '+agenciesAffected);
						system.debug(LoggingLevel.ERROR, '[LF]: SAsInvolved '+SAsInvolved);
                        system.debug(LoggingLevel.ERROR, '[LF]: SAsNotInvolved '+SAsNotInvolved);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesWithMultipleCode '+agenciesWithMultipleCode);
						system.debug(LoggingLevel.ERROR, '[LF]: agenciesWithSingleCode '+agenciesWithSingleCode);

						if(!agenciesWithSingleCode.isEmpty())
						{
							// Apply cascade changes: change code + data migration
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesWithSingleCode, cascadingTOCs, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config2, accounts, accountsChangeCode, AMS_Utils.APPROVAL, agenciesWithSingleCode));
						}

						if(!agenciesWithMultipleCode.isEmpty())
						{
							// Apply cascade + no cascade changes: change code + data migration
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesWithMultipleCode, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.APPROVAL, agenciesWithMultipleCode));
						}

						// Apply change of location to children SAs not explicitly involved in the change
						if(SAsNotInvolved.size()>0){
							//change code generated only for the agencies not affected by any other change
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, SAsNotInvolved, changeOfLocation, accounts, oscarOnlineAccreditation));
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config3, accounts, accountsChangeCode, AMS_Utils.APPROVAL, SAsNotInvolved));
						}


					} else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() == 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing not cascade changes on approval');
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.APPROVAL, new Set<Id> {oscar.Account__c}));
						accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, new Set<Id> {oscar.Account__c}, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));

						// in case of location (for the moment is 100% but only God knows what will happen in the future)
						// I'll apply the change and generate a CHL also to the SAs
						if(changeContainsLocation  && agencyToSAs.get(oscar.Account__c)!=null){
							//We'll apply CHL to all dependent SAs either involved or not involved
							allSAs.addAll(SAsInvolved);
							allSAs.addAll(SAsNotInvolved);
							changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.APPROVAL, allSAs));
							accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, allSAs, changeOfLocation, accounts, oscarOnlineAccreditation));
						}

					} else if (nonCascadingTOCs.length() == 0 && cascadingTOCs.length() > 0) {
						system.debug(LoggingLevel.ERROR,'[LF]: AMS_OSCARTriggerHandler() Processing cascade changes on approval');
						agenciesAffected.add(oscar.Account__c);
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.APPROVAL, agenciesAffected));

						accountsToUpdate.putAll(AMS_Utils.copyDataToAccountForAgencyChanges(oscar, agenciesAffected, oscar.Type_of_change__c, accounts, oscarOnlineAccreditation));
						// change of location is not affecting this scenario
					}

					//APPLY HIERARCHY CHANGES
					//Hierarchy changes are applied to the agencies in the process detail and also to the OSCAR Account
					agenciesAffected.add(oscar.Account__c);

					/*MOVED TO SANITY CHECK
					Boolean isChangeOwnershipToIATA = tocList.contains(AMS_Utils.OWNERSHIP_IATA) ? true : false;
					//All terminated agencies that would be left without parent MUST be automatically migrated, thus following their parents
					//Exception to the above rule is when we have change of ownership to IATA, where BRs will be left as standalone
					Set<Id> agenciesToMigrate = AMS_HierarchyHelper.addTerminatedDescendants(agenciesAffected, agencyTerminatedChildAgencies, isChangeOwnershipToIATA, accounts);
					system.debug('AgenciesToMigrateHierarchy: ' + agenciesToMigrate);
					system.debug('AgenciesToMigrateData: ' + agenciesAffected);

					AMS_HierarchyHelper.HierarchyStruct hs = processHierarchyChanges(oscar, accounts, accountHierarchyRelationships, agenciesToMigrate);

					hierarchyChanges.add(hs);
					************************/

					//check if ownership needs to be copied from online form to Accounts
					if (AMS_Utils.ownershipIsToBeMigrated(oscar.Type_of_change__c)){
						accountsAffectedPerOnlineAccreditation.put(oscar.AMS_Online_Accreditation__c, agenciesAffected);

						//fill map to check ownership alignment in hierarchy
						if(cascadingTOCs.contains(AMS_Utils.OWNERSHIP_IATA)){
							//the target agency owners will be compared with the agency owners we are trying to migrate to the target agency hierarchy
							Set<Id> agsToCompareOwner = new Set<Id>(agenciesAffected);
							agsToCompareOwner.add(oscar.AMS_Target_Agency__c);
							accsToCompareOwnership.put(oscar.Id, agsToCompareOwner);
						}

					}


				} else if (oldOSCAR.STEP4__c <> AMS_Utils.PASSED && oscar.STEP4__c == AMS_Utils.PASSED) {
					if (nonCascadingTOCs.length() > 0 && nonCascadingTOCs.containsIgnoreCase(AMS_Utils.LOCATION_TYPE)) {
						System.debug('AGENCY CHANGES: Processing Location Type Change Codes on Withdrawal.');

                        Set<Id> accAffected;
                        //In this situation we only need to create change code for the oscar account
                        if(oscar.Change_of_location_type_behavior__c == AMS_Utils.CHLOCTYPEBEHAVIOR_NOSWAP)
                            accAffected = new Set<Id> {oscar.Account__c};
                        else{ //default swap with parent, create change code for both accounts involved in the swap
                            if(pds == null || (pds != null && pds.size() != 1))
                                throw new AMSException('Something went wrong! The Hierarchy Account selection for Change of Location Type must have a single entry for this Oscar. Please contact your administrator.');

                            accAffected = new Set<Id> {oscar.Account__c, pds.get(0).Account__c};
                        }

                        changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.WITHDRAWAL, accAffected));
					} else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() > 0) {
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config2, accounts, accountsChangeCode, AMS_Utils.WITHDRAWAL, agenciesAffected));

						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.WITHDRAWAL, new Set<Id> {oscar.Account__c}));
					} else if (nonCascadingTOCs.length() > 0 && cascadingTOCs.length() == 0) {
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.WITHDRAWAL, new Set<Id> {oscar.Account__c}));
					} else if (nonCascadingTOCs.length() == 0 && cascadingTOCs.length() > 0) {
						agenciesAffected.add(oscar.Account__c);
						changesContainer.add(AMS_ChangeCodesHelper.generateChangeCodes(oscar, config, accounts, accountsChangeCode, AMS_Utils.WITHDRAWAL, agenciesAffected));
					}

				}else if (!oldOSCAR.Apply_Penalty_Fee__c && oscar.Apply_Penalty_Fee__c) {
					System.debug(loggingLevel.ERROR, '____ [cls AMS_OSCARTriggerHandler - processAgencyChanges] oscar.Apply_Penalty_Fee__c - ' + oscar.Apply_Penalty_Fee__c);
					Agency_Applied_Change_code__c lastChangeCode = accountsChangeCode.get(oscar.Account__c);
					AMS_OSCAR_JSON.ChangeCode changeCode = new AMS_OSCAR_JSON.ChangeCode();

					changeCode.name = 'LNF';
					//changeCode.memoText = lastChangeCode.Bulletin_Information__c;
					changeCode.reasonCode = lastChangeCode.Reason_Code__c;
					changeCode.reasonDesc = lastChangeCode.Reason_Description__c;
					changeCode.status = AMS_Utils.getIATANumericStatus(accounts.get(oscar.Account__c).Status__c);

					System.debug(loggingLevel.ERROR, '____ [cls AMS_OSCARTriggerHandler - processAgencyChanges] changeCode - ' + changeCode);

					changesContainer.add(new AMS_Utils.Container(new List<AMS_OSCAR_JSON.ChangeCode>{changeCode}, new List<Account>{accounts.get(oscar.Account__c)}, new List<AMS_Oscar__c>{oscar}));
				}

			}
		}


		Savepoint sp = Database.setSavepoint();

		List<AMS_ChangeCodesHelper.ObjectChangesStruct> objectChanges = new List<AMS_ChangeCodesHelper.ObjectChangesStruct> ();
		try {

				
			Map<Id,AMS_AccountRoleCreator.OldAndNewOwners> oldAndNewOwnersMap = new Map<Id,AMS_AccountRoleCreator.OldAndNewOwners>();
			//Migrate Ownership
			if (!accountsAffectedPerOnlineAccreditation.isEmpty()) {
				system.debug('processAgencyChanges() --> accountsAffectedPerOnlineAccreditation = ' + accountsAffectedPerOnlineAccreditation);

				oldAndNewOwnersMap = AMS_AccountRoleCreator.runRoleCreatorForOnlineAccreditations(accountsAffectedPerOnlineAccreditation, !isSanityCheck);

				//verify ownership alignment
				if(accsToCompareOwnership.size()>0 && !AMS_HierarchyHelper.checkHierarchyIntegrity(accsToCompareOwnership))
					throw new AMSException('Performing this operation will result in hierarchy ownership inconsistency. Please make sure the owners being processed match with the owners of the target agency.');
			}

			set<Account> accountToupdateSet = new set<Account>();

			for(Id acctId : accountsToUpdate.keySet())
			{
				accountToupdateSet.add(accounts.get(acctId));
			}


			//************Create Change Codes History ****************
			//
			//
			

			
			List<Account> accsToUpdateFromCC = new List<Account>();

			//insert the change codes
			if (changesContainer.size() > 0) {
				List<AMS_OSCAR_JSON.ChangeCode> changeCodes = new List<AMS_OSCAR_JSON.ChangeCode>();
				List<Account> accts = new List<Account>();
				List<AMS_OSCAR__c> theoscars = new List<AMS_OSCAR__c>();

				//merge everything
				for (AMS_Utils.Container c : changesContainer) {

				//All lists must have the same size in order to create correctly the change codes

					changeCodes.addAll(c.changeCodes);
					accts.addAll(c.accts);
					theoscars.addAll(c.oscars);

					integer index = 0;
					for(Account acc : c.accts)
					{
		
					

						//******* Add "Custom" changes struct for the Ownership mapping ******** INI

						AMS_AccountRoleCreator.OldAndNewOwners oldNewOwnersByOscar = oldAndNewOwnersMap.get(theoscars[index].AMS_Online_Accreditation__c);

						if(oldNewOwnersByOscar != null )
						{
							String oldOwnerCSV,newOwnerCSV = '';

							if (oldNewOwnersByOscar.getOldOwnersByAccountId(acc.Id) != null) oldOwnerCSV = oldNewOwnersByOscar.getOldOwnersByAccountId(acc.Id).allOwnersCSV;
							if (oldNewOwnersByOscar.getNewOwnersByAccountId(acc.Id) != null) newOwnerCSV = oldNewOwnersByOscar.getNewOwnersByAccountId(acc.Id).allOwnersCSV;

							AMS_ChangeCodesHelper.ObjectChange objectChangesOwnership;

							if(oldOwnerCSV != newOwnerCSV) objectChangesOwnership = new AMS_ChangeCodesHelper.ObjectChange('Account','Owners',oldOwnerCSV,newOwnerCSV);

							if( objectChangesOwnership != null && accountsToUpdate.get(acc.Id) == null)
							{
								AMS_ChangeCodesHelper.ObjectChangesStruct acctChangesStruct = new AMS_ChangeCodesHelper.ObjectChangesStruct(new List <AMS_ChangeCodesHelper.ObjectChange> {objectChangesOwnership});
								objectChanges.add(acctChangesStruct);

								system.debug('DDD accountsToUpdate add Owners Info:' + accountsToUpdate.get(acc.Id));

							}

							else if ( objectChangesOwnership != null)
								accountsToUpdate.get(acc.Id).changes.add(objectChangesOwnership);

						}

	

						system.debug('DDD accountsToUpdate.get(acc):' + accountsToUpdate.get(acc.Id));

						objectChanges.add(accountsToUpdate.get(acc.Id));

						index++;
					}


				}
				//create change codes

				accsToUpdateFromCC = AMS_ChangeCodesHelper.createAAChangeCodes(objectChanges,changeCodes, theoscars, accts, false);
			}

			List<Account> mergedAccountUpdate = mergeAccountsToUpdate(accsToUpdateFromCC, new List<Account>(accountToupdateSet));

			if (!mergedAccountUpdate.isEmpty()) {
				AMS_AccountTriggerHandler.processMinorChangesValidationFlag = true;
				update mergedAccountUpdate;
				AMS_AccountTriggerHandler.processMinorChangesValidationFlag = false;

			}
			system.debug('DDD11 hierarchyChanges.size(): ' + hierarchyChanges.size());

			if (hierarchyChanges.size() > 0) {
				List<AMS_Agencies_Hierarchy__c> allHierarchiesToInsert = new List<AMS_Agencies_Hierarchy__c>();
				List<AMS_Agencies_relationhip__c> allRelationsToUpdate = new List<AMS_Agencies_relationhip__c>();
				List<AMS_Agencies_relationhip__c> allRelationsToInsert = new List<AMS_Agencies_relationhip__c>();
				List<AMS_Agencies_relationhip__c> allRelationsToDelete = new List<AMS_Agencies_relationhip__c>();
				List<Id> allHierarchiesToDelete = new List<Id>();

				for (AMS_HierarchyHelper.HierarchyStruct hs : hierarchyChanges) {
					if (hs.relationsToUpdate != null)
						allRelationsToUpdate.addAll(hs.relationsToUpdate);
					if (hs.relationsToInsert != null)
						allRelationsToInsert.addAll(hs.relationsToInsert);
					if (hs.relationsToDelete != null)
						allRelationsToDelete.addAll(hs.relationsToDelete);
					if (hs.hierarchiesToDelete != null)
						allHierarchiesToDelete.addAll(hs.hierarchiesToDelete);
				}

				if (!allRelationsToDelete.isEmpty())
					delete allRelationsToDelete;
				if (!allRelationsToUpdate.isEmpty())
					update allRelationsToUpdate;
				if (!allRelationsToInsert.isEmpty())
					insert allRelationsToInsert;

				if(!allHierarchiesToDelete.isEmpty()){
					List<AMS_Agencies_Hierarchy__c> hierarchiesDel = new List<AMS_Agencies_Hierarchy__c>([SELECT Id FROM AMS_Agencies_Hierarchy__c WHERE Id IN :allHierarchiesToDelete]);
					if (!hierarchiesDel.isEmpty())
						delete hierarchiesDel;
				}


				//**** Generate Change Code History for Location Type and IATA Code


				List<AMS_Agency_A_Change_code_History__c> extraCCHistory = new List <AMS_Agency_A_Change_code_History__c>();

				system.debug('DDD11 aaccHistoryPerAcct: ' + AMS_ChangeCodesHelper.aaccHistoryPerAcct);


				for(Account acc : accsToUpdateFromCC)
				{
					if(! AMS_AgencyRelationshipTriggerHandler.accsToUpdateSet.contains(acc))
						AMS_AgencyRelationshipTriggerHandler.accsToUpdateSet.add(acc);						
				}

				for(Account acc : AMS_AgencyRelationshipTriggerHandler.accsToUpdateSet)
				{
					system.debug('DDD11 acc.Id: ' + acc.Id);

					if(AMS_ChangeCodesHelper.aaccHistoryPerAcct.containsKey(acc.Id))
					{
						system.debug('DDD11 New Info Acct ID: ' + acc.id);
						system.debug('DDD11 New Location_Type__c: '  + acc.Location_Type__c);
						//system.debug('DDD11 New acc.parent.IATACode__c: '  + accounts.get(acc.ParentId).IATACode__c);
					

						//******* Add "Custom" changes struct for the Location Type mapping ******** INI
						
						if(accountStructPerAcct.containsKey(acc.Id) && acc.Location_Type__c !=  accountStructPerAcct.get(acc.Id).locationType)
						{
							
							extraCCHistory.add( new AMS_Agency_A_Change_code_History__c(
		                                                        Agency_Applied_Change_Code__c = AMS_ChangeCodesHelper.aaccHistoryPerAcct.get(acc.Id).changeCode.Id,
		                                                        Object_API_Name__c            = 'Account',
		                                                        Field_API_Name__c             = 'Location_Type__c',
			                                                    Field_Old_Value__c            = accountStructPerAcct.get(acc.Id).locationType,
			                                                    Field_New_Value__c            = acc.Location_Type__c
		                                                        )
												);

						}


						//******* Add "Custom" changes struct for the Parent Iata Code mapping ******** INI

						//If new location type is HO parent Iata code is null
						
						String newParentIATACode = null;

						if(accounts.containsKey(acc.ParentId)) 
						{
							system.debug('DDD11 New acc.parentId: '  + accounts.get(acc.ParentId).IATACode__c);
							newParentIATACode = accounts.get(acc.ParentId).IATACode__c;
							
						}
						
						
						if(accountStructPerAcct.containsKey(acc.Id) && accountStructPerAcct.get(acc.Id).parentIATACode != newParentIATACode)
						{
							
							extraCCHistory.add( new AMS_Agency_A_Change_code_History__c(
		                                                        Agency_Applied_Change_Code__c = AMS_ChangeCodesHelper.aaccHistoryPerAcct.get(acc.Id).changeCode.Id,
		                                                        Object_API_Name__c            = 'Account',
		                                                        Field_API_Name__c             = 'Parent.IATACode__c',
			                                                    Field_Old_Value__c            = accountStructPerAcct.get(acc.Id).parentIATACode,
			                                                    Field_New_Value__c            = newParentIATACode
		                                                        )
												);
						}

					}

				}

				if (!extraCCHistory.isEmpty()) 
				{

					        System.debug('The list of Change Codes History to add is (EXTRA) ' + extraCCHistory.size());

					        insert extraCCHistory;
				}
				AMS_ChangeCodesHelper.aaccHistoryPerAcct.clear();
			}

		} catch (Exception ex) {
			System.debug('DML exception: ' + ex);
			Database.rollback(sp);
			throw ex;
		}

	}

	public static AMS_HierarchyHelper.HierarchyStruct processHierarchyChanges(AMS_OSCAR__c oscar, Map<Id, Account> accounts, Map<Id, List<AMS_Agencies_relationhip__c>> hierarchies, Set<Id> agenciesAffected) {

		system.debug( 'DDD2 processHierarchyChanges ');
		keepSALocationTypeFlag = false;

		//this container will store all database operations that need to be performed
		AMS_HierarchyHelper.HierarchyStruct hierarchyChanges = new AMS_HierarchyHelper.HierarchyStruct();



		Set<String> tocList = new Set<String>();
		tocList.addAll(oscar.Type_of_change__c.split(';'));

		Account oscarAccount = accounts.get(oscar.Account__c);

		if (tocList.contains(AMS_Utils.LOCATION_TYPE))
			hierarchyChanges = processChangeOfLocationType(oscar, accounts, hierarchies);
		else if (tocList.contains(AMS_Utils.OWNERSHIP_IATA)) {
			keepSALocationTypeFlag = true;
			hierarchyChanges = processChangeOfOwnershipToIATA(oscar, hierarchies, agenciesAffected, accounts);
		} else if (tocList.contains(AMS_Utils.OWNERSHIP_NON_IATA)) {
			keepSALocationTypeFlag = true;
			hierarchyChanges = processChangeOfOwnershipToNonIATA(oscar, accounts, hierarchies, agenciesAffected);
			//change of location for SA where the oscar has a target agency defined. this requires the SA to move under the target agency
		} else if ((tocList.contains(AMS_Utils.LOCATION) || tocList.contains(AMS_Utils.LOCATION_INSPECTION)) && oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.SA) && oscar.AMS_Target_Agency__c != null) {
			keepSALocationTypeFlag = true;
			hierarchyChanges = processSAChangeOfLocation(oscar, accounts, hierarchies);
		}

		system.debug( 'DDD2 AMS_HierarchyHelper.hierarchyChanges: ' + hierarchyChanges);

		return hierarchyChanges;
	}

	public static AMS_HierarchyHelper.HierarchyStruct processChangeOfLocationType(AMS_OSCAR__c oscar, Map<Id, Account> accounts, Map<Id, List<AMS_Agencies_relationhip__c>> hierarchies) {


		system.debug( 'DDD2 processChangeOfLocationType ');

		Id oscarAccountId = oscar.Account__c;

		//get the parent of the oscar account
		Account child = accounts.get(oscarAccountId);

		Account parent;

		if (child != null && child.parentId != null)
			parent = accounts.get(child.parentId);

		system.debug('AGENCY CHANGES: the parent that will become child: ' + parent);

		List<AMS_Agencies_relationhip__c> hierarchyRelationships = hierarchies.get(oscar.Account__c);

		if (child != null && parent != null)
			return AMS_HierarchyHelper.switchParentWithChild(child.Id, parent.Id, oscar.Change_of_location_type_behavior__c, accounts, hierarchyRelationships);

		throw new AMSException('Data inconsistency issue.');

	}

	public static AMS_HierarchyHelper.HierarchyStruct processChangeOfOwnershipToIATA(AMS_OSCAR__c oscar, Map<Id, List<AMS_Agencies_relationhip__c>> hierarchies, Set<Id> agenciesAffected, Map<Id, Account> accounts) {

		System.debug('AGENCY CHANGES: Processing change of ownership. Scenario IATA Buys IATA');

		Id targetHierarchyHO = oscar.AMS_Target_Agency__c;
		//the hierarchy relationships where the agencies will be migrated to
		List<AMS_Agencies_relationhip__c> newHierarchy = hierarchies.get(targetHierarchyHO);
		List<AMS_Agencies_relationhip__c> currentHierarchy = hierarchies.get(oscar.Account__c);
		AMS_HierarchyHelper.HierarchyStruct relationshipsToManage;

		relationshipsToManage = AMS_HierarchyHelper.migrateAccountsToExistingHierarchy(oscar.Account__c, currentHierarchy, targetHierarchyHO, newHierarchy, agenciesAffected, accounts);

		if (relationshipsToManage.errorMessage != null)
			oscar.addError(relationshipsToManage.errorMessage);

		return relationshipsToManage;

	}

	public static AMS_HierarchyHelper.HierarchyStruct processChangeOfOwnershipToNonIATA(AMS_OSCAR__c oscar, Map<Id, Account> accounts, Map<Id, List<AMS_Agencies_relationhip__c>> hierarchies, Set<Id> agenciesAffected) {
		//DEFINE A SET OF LOCATION CLASSES WHERE THE LOGIC SHOULD BE APPLIED

		System.debug('AGENCY CHANGES: Processing change of ownership. Scenario Non IATA Buys IATA');

		List<AMS_Agencies_relationhip__c> accountHierarchy = hierarchies.get(oscar.Account__c);
		AMS_HierarchyHelper.HierarchyStruct relationshipsToManage;

		//get the relationships that need to be updated/inserted/deleted
		relationshipsToManage = AMS_HierarchyHelper.migrateAccountsToNewHierarchy(oscar.Account__c, accounts, accountHierarchy, agenciesAffected);

		if (relationshipsToManage.errorMessage != null)
			oscar.addError(relationshipsToManage.errorMessage);

		return relationshipsToManage;
	}

	public static AMS_HierarchyHelper.HierarchyStruct processSAChangeOfLocation(AMS_OSCAR__c oscar, Map<Id, Account> accounts, Map<Id, List<AMS_Agencies_relationhip__c>> hierarchies) {

		System.debug('AGENCY CHANGES: Processing change of location. OSCAR opened on SA and has a Target agency defined.');

		Id oscarAccountId = oscar.Account__c;

		//the child in the relation that needs to be moved
		Account child = accounts.get(oscarAccountId);
		//the new parent for the child
		Account parent = accounts.get(oscar.AMS_Target_Agency__c);

		List<AMS_Agencies_relationhip__c> hierarchyRelationships = hierarchies.get(oscar.Account__c);

		if (child != null && parent != null)
			return AMS_HierarchyHelper.reparentChildSA(child.Id, parent.Id, accounts, hierarchyRelationships);

		throw new AMSException('Data inconsistency issue.');

	}

	public static boolean performOscarValidations(Set<String> toclist, Set<Id> agenciesAffected, AMS_OSCAR__c oscar, Map<Id, Account> accounts, Map<Id, List<AMS_Agencies_relationhip__c>> accountHierarchyRelationships, Map<ID,AMS_Pax_Accreditation_Form__c> stagingAreas) {

		boolean validationsPassed = true;
		Set<Id> agenciesToMigrate = new Set<Id>(agenciesAffected);
		agenciesToMigrate.add(oscar.Account__c);

		//Do not allow change of ownerships that leave an hierarchy without an HO
		if (tocList.contains(AMS_Utils.OWNERSHIP_IATA) || tocList.contains(AMS_Utils.OWNERSHIP_NON_IATA)) {
			//Set<Id> agenciesToMigrate = new Set<Id>(agenciesAffected);
			//agenciesToMigrate.add(oscar.Account__c);
			Set<Id> agenciesNotMigrated = AMS_HierarchyHelper.getAccountNotMigrated(accountHierarchyRelationships.get(oscar.Account__c), agenciesToMigrate);
			String error = AMS_HierarchyHelper.validateIncompleteMigration(agenciesNotMigrated);
			if (error != null){
				oscar.addError(error);
				validationsPassed=false;
			}
		}

		if (tocList.contains(AMS_Utils.OWNERSHIP_IATA) && oscar.AMS_Target_Agency__c == null){
			oscar.AMS_Target_Agency__c.addError('The field "Target Agency" is mandatory when a change of ownership to IATA agent is being performed.');
			validationsPassed= false;
		}

		if(tocList.contains(AMS_Utils.REMOVALTRADENAME) && (stagingAreas.get(oscar.AMS_Online_Accreditation__c)==null || !String.isBlank(stagingAreas.get(oscar.AMS_Online_Accreditation__c).Trade_Name__c))){
			oscar.AMS_Target_Agency__c.addError('If the type of change includes "'+AMS_Utils.REMOVALTRADENAME+'" the field Trade Name must be empty.');
			validationsPassed= false;
		}


		Account oscarAccount = accounts.get(oscar.Account__c);
		if (tocList.contains(AMS_Utils.LOCATION_TYPE)){
			//block change of location type in Head Office
			if(oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.HO) || oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.AO)){
				oscar.addError('OSCAR for Change of Location Type cannot be performed in an HO.');
				validationsPassed=false;
			}

			else if(oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.BR)){
				if(oscar.Change_of_location_type_behavior__c == AMS_Utils.CHLOCTYPEBEHAVIOR_NOSWAP){
					oscar.Change_of_location_type_behavior__c.addError('The field Change of location type behavior cannot have value Dont change the parent when the OSCAR is opened for a Branch.');
					validationsPassed=false;
				}
			}
			//do not allow change of location type behaviour to be dont change the parent when the oscar agency is directly under an HO
			else if(oscarAccount.Parent.Location_Type__c.equalsIgnoreCase(AMS_Utils.HO) || oscarAccount.Parent.Location_Type__c.equalsIgnoreCase(AMS_Utils.AO)){
				if(oscar.Change_of_location_type_behavior__c == AMS_Utils.CHLOCTYPEBEHAVIOR_NOSWAP){
					oscar.Change_of_location_type_behavior__c.addError('The field Change of location type behavior cannot have value Dont change the parent when the oscar is opened for an account directly under an HO.');
					validationsPassed=false;
				}
			}

		}else{
			//Only allowed to be filled in for change of Location Type
			if(oscar.Change_of_location_type_behavior__c != null){
				oscar.Change_of_location_type_behavior__c.addError('The field Change of location type behavior can only be filled for changes of Location Type.');
				validationsPassed=false;
			}
		}


		//Target Agency field validations
		if (oscar.AMS_Target_Agency__c != null){
			//Target Agency field only allowed on change of ownership iata to iata and change of Location or Location with Inspection
			if (tocList.contains(AMS_Utils.LOCATION) || tocList.contains(AMS_Utils.LOCATION_INSPECTION) || tocList.contains(AMS_Utils.OWNERSHIP_IATA)){

				if(tocList.contains(AMS_Utils.LOCATION) || tocList.contains(AMS_Utils.LOCATION_INSPECTION)){
					/*if(!oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.SA)){
						oscar.AMS_Target_Agency__c.addError('A change of location for an agency which is not an “SA” cannot specify a target agency');
						validationsPassed=false;
					}
					else */if((tocList.contains(AMS_Utils.OWNERSHIP_IATA) || tocList.contains(AMS_Utils.OWNERSHIP_NON_IATA)) && oscarAccount.Location_Type__c.equalsIgnoreCase(AMS_Utils.SA)){
						oscar.AMS_Target_Agency__c.addError('A change of location for an SA agency, which specify a target agency, cannot be mixed with a change of ownership');
						validationsPassed=false;
					}

				}
				//Target agency -> A validation must ensure that only accounts with location type “HO” or “BR” should be selected.
				Account target = accounts.get(oscar.AMS_Target_Agency__c);
				if(target != null)
					if(target.Location_Type__c != AMS_Utils.BR && target.Location_Type__c != AMS_Utils.HO && target.Location_Type__c != AMS_Utils.AO){
						oscar.AMS_Target_Agency__c.addError('The target Agency Location Type must be either HO, AO or BR');
						validationsPassed=false;
					}

			}
			else{
				oscar.AMS_Target_Agency__c.addError('Target Agency field can only be filled for the following types of changes: Ownership to IATA Agent, Location and Location with inspection.');
				validationsPassed=false;
			}
		}

		//When performing change of shareholding all active hierarchy agencies must be selected
		if (tocList.contains(AMS_Utils.MAJ_SHAREHOLDING) || tocList.contains(AMS_Utils.MIN_SHAREHOLDING) ) {
			System.debug('Agencies Affected: ' + agenciesToMigrate);
			System.debug('Hierarchy Agencies: ' + accountHierarchyRelationships.get(oscar.Account__c));
			if(!AMS_HierarchyHelper.isAllHierarchySelected(agenciesToMigrate, accountHierarchyRelationships.get(oscar.Account__c), accounts)){
				oscar.addError('When performing a change of shareholding all the active agencies in the hierarchy must be selected.');
				validationsPassed=false;
			}
		}
		//When performing change of shareholding all active hierarchy agencies must be selected
		if (tocList.contains(AMS_Utils.MAJ_SHAREHOLDING) || tocList.contains(AMS_Utils.MIN_SHAREHOLDING) ) {
			System.debug('Agencies Affected: ' + agenciesToMigrate);
			System.debug('Hierarchy Agencies: ' + accountHierarchyRelationships.get(oscar.Account__c));
			if(!AMS_HierarchyHelper.isAllHierarchySelected(agenciesToMigrate, accountHierarchyRelationships.get(oscar.Account__c), accounts)){
				oscar.addError('When performing a change of shareholding all the active agencies in the hierarchy must be selected.');
				validationsPassed=false;
			}
		}

		//When performing change of remittance frequency (VMFR) all active hierarchy agencies (except for BRs abroad) must be selected
		if (tocList.contains(AMS_Utils.VFMR) ) {
			System.debug('Agencies Affected: ' + agenciesToMigrate);
			System.debug('Hierarchy Agencies: ' + accountHierarchyRelationships.get(oscar.Account__c));
			if(!AMS_HierarchyHelper.isAllHierarchySelected(agenciesToMigrate, accountHierarchyRelationships.get(oscar.Account__c), accounts)){
				oscar.addError('When performing a change of remittance frequency (VMFR) all the active agencies in the hierarchy must be selected. Only branches abroad can be excluded');
				validationsPassed=false;
			}

		}

		return validationsPassed;

	}


	private static void updateCaseInfo() {

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;
		Map<Id, AMS_OSCAR__c> newMap = (Map<Id,AMS_OSCAR__c>) Trigger.newMap;

		List<AMS_OSCAR__c> updatedOscars = new List<AMS_OSCAR__c>();
		for(AMS_OSCAR__c oscar : (List<AMS_OSCAR__c>)Trigger.New){
			if(
				(oscar.Status__c != null && oscar.Status__c != oldMap.get(oscar.Id).Status__c)
				|| oscar.OwnerId != oldMap.get(oscar.Id).OwnerId
				|| (oscar.Sanity_check_results__c == AMS_Utils.PASSED && oldMap.get(oscar.Id).Sanity_check_results__c != AMS_Utils.PASSED && oscar.Process__c != AMS_Utils.VOLRELINQUISH)
				|| (oscar.Termination_Date__c != oldMap.get(oscar.Id).Termination_Date__c && oscar.Process__c == AMS_Utils.VOLRELINQUISH)
			){
				updatedOscars.add(oscar);
			}
		}

		if(updatedOscars.isEmpty()) return;

		List<Case> casesToUpdate = new List<Case>();
		for(Case c : [SELECT Id, Status, OwnerId, Oscar__c, Process_Start_Date__c from CASE WHERE Oscar__c != null AND RecordType.Name = 'OSCAR Communication' AND Oscar__c IN :updatedOscars
						AND ((Oscar__r.Process__c = 'BANK.ACCOUNT.CHANGES' AND ParentId = null) OR (Oscar__r.Process__c != 'BANK.ACCOUNT.CHANGES'))]){

			AMS_OSCAR__c updatedOSCAR = newMap.get(c.Oscar__c);
			Boolean caseChanged = false;

	        if ( AMS_OSCARTriggerHandler.closedStatusMapping.containsKey(updatedOSCAR.Status__c) ) {
	        	String closedStatus = AMS_OSCARTriggerHandler.closedStatusMapping.get(updatedOSCAR.Status__c);
	        	if(c.Status != closedStatus){
	        		c.Status = closedStatus;
	        		caseChanged = true;
	        	}
	        }else if(c.Status != updatedOSCAR.Status__c){
        		c.Status = updatedOSCAR.Status__c;
        		caseChanged = true;
        	}

        	if(c.OwnerId != updatedOSCAR.OwnerId){
        		c.OwnerId = updatedOSCAR.OwnerId;
        		caseChanged = true;
        	}
        	if(c.Process_Start_Date__c == null && updatedOSCAR.Process__c != AMS_Utils.VOLRELINQUISH){
        		c.Process_Start_Date__c = updatedOSCAR.Sanity_check_received__c;
        		caseChanged = true;
        	}
        	if(c.Process_Start_Date__c != updatedOSCAR.Termination_Date__c && updatedOSCAR.Process__c == AMS_Utils.VOLRELINQUISH){
        		c.Process_Start_Date__c = updatedOSCAR.Termination_Date__c;
        		caseChanged = true;
        	}

		    if(caseChanged) casesToUpdate.add(c);
		}

		if(!casesToUpdate.isEmpty()) update casesToUpdate;
	}

	//TD: udpate case reason. Used for calculating KPIs
	public static void updateCaseKPIFields() {

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		Map<Id, AMS_OSCAR__c> mapOscars = new Map<Id, AMS_OSCAR__c>();
		for (AMS_OSCAR__c oscar : (List<AMS_OSCAR__c>)Trigger.New ) {
			if (
					Trigger.isInsert ||
			    	(
			    		(oscar.Reason_For_KPI__c != oldMap.get(oscar.id).Reason_For_KPI__c) ||
			        	(oscar.Process_Start_Date__c != oldMap.get(oscar.id).Process_Start_Date__c) ||
			        	(oscar.Dossier_Reception_Date__c != oldMap.get(oscar.id).Dossier_Reception_Date__c)
			        )
			    )
				mapOscars.put(oscar.id, oscar);
		}

		if(mapOscars.isEmpty()) return;

		try {
			List<Case> lsCaseToUpdate = new List<Case>();
			for(case ca:[select id, Reason1__c, OSCAR__c, Account.IATA_ISO_Country__r.Name, Account.Region_Formula__c from Case where OSCAR__c in:mapOscars.keySet() AND RecordType.Name = 'OSCAR Communication' AND ( ParentId = null or Parent.RecordType.Name != 'OSCAR Communication' )]){
				lsCaseToUpdate.add(new case(id = ca.id
											, Reason1__c = mapOscars.get(ca.OSCAR__C).Reason_For_KPI__c != null ? mapOscars.get(ca.OSCAR__C).Reason_For_KPI__c : ca.Reason1__c
											, Process_Start_Date__c = mapOscars.get(ca.OSCAR__C).Process_Start_Date__c
											, BSPCountry__c = ca.Account.IATA_ISO_Country__r.Name
											, Region__c = ca.Account.Region_formula__c
											, Dossier_reception_date__c = mapOscars.get(ca.OSCAR__C).Dossier_Reception_Date__c));
			}

			if(!lsCaseToUpdate.isEmpty())
				update lsCaseToUpdate;
		} catch (exception e) {
			system.debug('DTULLO 39 --> exception --> ' + e.getMessage());
		}
	}

	//the oscar process requires updates on the accounts on 2 situations
	//-when a change code is generated (in this situation only the status is updated)
	//-when migrating fields from staging area to master data
	//because the above situations are done in separate ocasions, we need to merge the account updates in only one list
	//to prevent double update on accounts
	private static List<Account> mergeAccountsToUpdate(List<Account> accountUpdatesFromChangeCodes, List<Account> accountUpdatesFromStagingArea){

		List<Account> mergedAccountsToUpdate = new List<Account>();

		//gather all account Ids into a set
		Map<Id, Account> mapA = new Map<Id, Account>(accountUpdatesFromStagingArea);
		Map<Id, Account> mapB = new Map<Id, Account>(accountUpdatesFromChangeCodes);


		Set<Id> allAccountsToUpdateIds = new Set<Id>();
		allAccountsToUpdateIds.addAll(mapA.keySet());
		allAccountsToUpdateIds.addAll(mapB.keySet());

		for(Id accId: allAccountsToUpdateIds){
			Account a;
			if(mapA.containsKey(accId))
				a = mapA.get(accId);
			if(mapB.containsKey(accId))
				if(a == null)
					a = mapB.get(accId);
				else
					a.Status__c = mapA.get(accId).Status__c;

			if(a!=null)
				mergedAccountsToUpdate.add(a);
		}

		return mergedAccountsToUpdate;

	}

	private static void handleCargoAgencyRegulations(){

		//Check if agency is a Cargo Agent
		List<AMS_OSCAR__c> oscarsToProcess = new List<AMS_OSCAR__c>();

		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		Map<Id,AMS_OSCAR__c> oscarAux = new Map<Id, AMS_OSCAR__c>([SELECT Id, Account__r.Sector__c, Account__r.CNS_Agency__c FROM AMS_OSCAR__c WHERE Id IN :Trigger.New]);

		//check which oscars are related to Cargo Agencies and have passed sanity check
		//for(AMS_OSCAR__c oscar:[SELECT Id, Account__r.Sector__c FROM AMS_OSCAR__c WHERE Id IN :Trigger.New]){
		for(AMS_OSCAR__c oscar:(List<AMS_OSCAR__c>)Trigger.New){
			if ((oscar.RecordTypeId == AMS_Utils.RECTYPE_NEW || oscar.RecordTypeId == AMS_Utils.RECTYPE_CERT) && oldMap.get(oscar.Id).STEP6__c <> AMS_Utils.PASSED && oscar.STEP6__c == AMS_Utils.PASSED){

				if(oscarAux.get(oscar.Id).Account__r.Sector__c == AMS_Utils.SECTOR_CARGO)
					oscarsToProcess.add(oscar);
			}
		}
		
		if(!oscarsToProcess.isEmpty()){
			List<AMS_OSCAR__c> oscarsToValidate = new List<AMS_OSCAR__c>();					
			for(AMS_OSCAR__c oscar : oscarsToProcess){
				
				// bypass validation for CNS if Custom Setting is not enabled
				if(!oscarAux.get(oscar.Id).Account__r.CNS_Agency__c || (oscarAux.get(oscar.Id).Account__r.CNS_Agency__c && CNS_Settings__c.getInstance().DGR_Validate_Certificates__c))
					oscarsToValidate.add(oscar);
			}
			
			if(oscarsToValidate.isEmpty() == false)
				validateCertificates(oscarsToValidate);

			createCargoAgencyRegulations(oscarsToProcess);
		}

	}

	private static void createCargoAgencyRegulations(List<AMS_OSCAR__c> oscars){

		List<AMS_Agency_Regulation__c> agencyregulationsToCreate = new List<AMS_Agency_Regulation__c>();
		Set<Id> onlineAccreditations = new Set<Id>();
		Set<Id> agencyRegulations = new Set<Id>();

		for(AMS_OSCAR__c oscar: oscars)
			onlineAccreditations.add(oscar.AMS_Online_Accreditation__c);

		//get the accreditation contacts from the staging area
		//all the trained staff accreditation contacts must generate an Agency Regulation object
		List<AMS_Accreditation_Contact__c> acToGenerateAgencyRegulation = new List<AMS_Accreditation_Contact__c>([
																			SELECT Id, First_name__c, Last_name__c, AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__r.Account__c,
																			Certificate_Name__c, Certificate_Issued_on__c, Type_of_Certificate__c, Certificate_Validity__c, Valid_until__c,
																			Certificate_Issuer__c, AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__c, Position_trained_staff__c, AgencyRegulation__c,
																			Air_cargo_transport_business_exp__c, IATA_FIATA_training_history__c, Training_dangerous_goods_completed__c
																			FROM AMS_Accreditation_Contact__c
																			WHERE AMS_Pax_Accreditation_Form__c IN :onlineAccreditations
																			AND RecordTypeId = :AMS_Utils.AccreditationContactTrainedStaffRT]);

		for(AMS_Accreditation_Contact__c ac: acToGenerateAgencyRegulation)
			if(ac.AgencyRegulation__c!=null)
				agencyRegulations.add(ac.AgencyRegulation__c);

		for(AMS_Accreditation_Contact__c ac: acToGenerateAgencyRegulation){

			AMS_Agency_Regulation__c agReg = new AMS_Agency_Regulation__c();

			if(ac.AgencyRegulation__c != null)
				agReg.Id = ac.AgencyRegulation__c;

			agReg.Certificate_Name__c = ac.Certificate_Name__c;
			agReg.Issued_on__c = ac.Certificate_Issued_on__c;
			agReg.Type_Of_Certificate__c = ac.Type_of_Certificate__c;
			agReg.Validity__c = ac.Certificate_Validity__c;
			agReg.First_Name__c = ac.First_name__c;
			agReg.Last_name__c = ac.Last_name__c;
			agReg.Issuer__c = ac.Certificate_Issuer__c;
			if(ac.AgencyRegulation__c == null)
				agReg.Account__c = ac.AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__r.Account__c;
			agReg.Position__c = ac.Position_trained_staff__c;
			agReg.Expiry_Date__c = ac.Valid_until__c;
			agReg.Oscar__c = ac.AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__c;

			//make sure the notification sent field in reset
			agReg.Notification_Sent__c = false;
			agReg.Air_cargo_transport_business_exp__c = ac.Air_cargo_transport_business_exp__c;
			agReg.IATA_FIATA_training_history__c = ac.IATA_FIATA_training_history__c;
			agReg.Training_dangerous_goods_completed__c = ac.Training_dangerous_goods_completed__c;

			agencyregulationsToCreate.add(agReg);

		}

		if(!agencyregulationsToCreate.isEmpty())
			upsert agencyregulationsToCreate;
	}

	private static void validateCertificates(List<AMS_OSCAR__c> oscars){

		//If an agency is handling dangerous goods, then it must
		//-	Have 2 DGR or DGA if it is an HO
		//-	Have 1 DGR or DGA if it is a BR
		Set<Id> onlineAccreditations = new Set<Id>();
		Set<Id> oscarIds = new Set<Id>();
		Map<Id, List<AMS_Accreditation_Contact__c>> trainedStaffPerAccount = new Map<Id, List<AMS_Accreditation_Contact__c>>();
		Set<Id> isoCountries = new Set<Id>();

		for(AMS_OSCAR__c oscar: oscars){
			onlineAccreditations.add(oscar.AMS_Online_Accreditation__c);
			oscarIds.add(oscar.Id);
		}

		List<AMS_OSCAR__c> oscarsList = new List<AMS_OSCAR__c>([SELECT Id, RecordTypeId, Account__c, AMS_Online_Accreditation__r.Location_Type__c, AMS_Online_Accreditation__r.Location_Class__c, AMS_Online_Accreditation__r.Is_your_firm_handling_Dangerous_Goods__c, AMS_Online_Accreditation__r.Branch_Office_Country__c, AMS_Online_Accreditation__r.Branch_Office_Country__r.ISO_Code__c, AMS_Online_Accreditation__r.CASS_Number__c FROM AMS_OSCAR__c WHERE Id IN :oscarIds]);

		for(AMS_OSCAR__c oscar: oscarsList)
			isoCountries.add(oscar.AMS_Online_Accreditation__r.Branch_Office_Country__c);

		//get all non expired trained staff
		List<AMS_Accreditation_Contact__c> allTrainedStaff = new List<AMS_Accreditation_Contact__c>(  [SELECT Id, Type_Of_Certificate__c, Valid_until__c, AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__r.Account__c
																									FROM AMS_Accreditation_Contact__c
																									WHERE AMS_Pax_Accreditation_Form__c IN :onlineAccreditations
																									AND RecordTypeId = :AMS_Utils.AccreditationContactTrainedStaffRT /*AND Valid_until__c > TODAY*/]);
		Id tsAccount = null;
		for(AMS_Accreditation_Contact__c trainedStaff :allTrainedStaff){

			System.debug('OSCARTriggerHandler -> validateCertificates: Found trained staff ' + trainedStaff);

			tsAccount = trainedStaff.AMS_Pax_Accreditation_Form__r.SAAM_Case__r.Oscar__r.Account__c;

			if(!trainedStaffPerAccount.containsKey(tsAccount))
				trainedStaffPerAccount.put(tsAccount, new List<AMS_Accreditation_Contact__c>());

			trainedStaffPerAccount.get(tsAccount).add(trainedStaff);
		}

		system.debug('validateCertificates -> isoCountries ' + isoCountries);

		//minimum requirements for location class 'R'
		Map<String, Integer> minimumHODgrRequirements = new Map<String, Integer>();
		Map<String, Integer> minimumBRDgrRequirements = new Map<String, Integer>();
        for(IATA_ISO_Country__c country : [SELECT Id, (SELECT Id, Minimum_DGR_BR__c, Minimum_DGR_HO__c, Location_Class__c
                                                       FROM AMS_Country_Specific_Attributes__r
                                                       WHERE RecordType.Name = 'DGR Minimum Requirements')
                                           FROM IATA_ISO_Country__c
                                           WHERE Id IN :isoCountries])
        {
        	system.debug('validateCertificates -> country.AMS_Country_Specific_Attributes__r ' + country.AMS_Country_Specific_Attributes__r);
            for(AMS_Country_Specific_Attribute__c att : country.AMS_Country_Specific_Attributes__r){
            	if(att != null){
                	minimumHODgrRequirements.put(''+country.Id+att.Location_Class__c, att.Minimum_DGR_HO__c == null ? 0 : Integer.valueOf(att.Minimum_DGR_HO__c));
                	minimumBRDgrRequirements.put(''+country.Id+att.Location_Class__c, att.Minimum_DGR_BR__c == null ? 0 : Integer.valueOf(att.Minimum_DGR_BR__c));
                }
            }
        }

        system.debug('validateCertificates -> minimumHODgrRequirements ' + minimumHODgrRequirements);
        system.debug('validateCertificates -> minimumBRDgrRequirements ' + minimumBRDgrRequirements);

		for(AMS_OSCAR__c oscar: oscarsList){
			if(oscar.RecordTypeId == AMS_Utils.RECTYPE_NEW){
				String locationClass = oscar.AMS_Online_Accreditation__r.Location_Class__c;
				String locationType = oscar.AMS_Online_Accreditation__r.Location_Type__c;
				System.debug('OSCARTriggerHandler -> validateCertificates: all trained staff ' + trainedStaffPerAccount.get(oscar.Account__c));
				String key = oscar.AMS_Online_Accreditation__r.Branch_Office_Country__c + locationClass;
				system.debug('validateCertificates - key -> ' + key);
				Integer minDgrHO = minimumHODgrRequirements.get(key) == null ? 0 : minimumHODgrRequirements.get(key);
				system.debug('validateCertificates -> minDgrHO ' + minDgrHO);
				Integer minDgrBR = minimumBRDgrRequirements.get(key) == null ? 0 : minimumBRDgrRequirements.get(key);
				system.debug('validateCertificates -> minDgrBR ' + minDgrBR);

				String countryCode = oscar.AMS_Online_Accreditation__r.Branch_Office_Country__r.ISO_Code__c;
				Integer cassNumber = Integer.valueOf(oscar.AMS_Online_Accreditation__r.CASS_Number__c);

				System.debug('CHECK CASS: ' + oscar.AMS_Online_Accreditation__r.CASS_Number__c);

				if(oscar.AMS_Online_Accreditation__r.Is_your_firm_handling_Dangerous_Goods__c == 'No'){
					//If an agency is non handling, it must have a certificate of awareness (DGA)
					if(oscar.AMS_Online_Accreditation__r.Location_Type__c == AMS_Utils.HO || oscar.AMS_Online_Accreditation__r.Location_Type__c == AMS_Utils.BR){
						System.debug('OSCARTriggerHandler -> validateCertificates: Non handling '+ oscar.AMS_Online_Accreditation__r.Location_Type__c + ' agency.');
						checkCertifications(trainedStaffPerAccount.get(oscar.Account__c), locationType, false, locationClass, countryCode, minDgrHO, minDgrBR, cassNumber);
					}
				}else{
					//RB: Here We will select only the DGR trained staff, which must have a Valid until date
					Map<Id, List<AMS_Accreditation_Contact__c>> trainedStaffDGR = new Map<Id, List<AMS_Accreditation_Contact__c>>();		
					List<AMS_Accreditation_Contact__c> listDGR = new List<AMS_Accreditation_Contact__c>();
					
					trainedStaffDGR.put(tsAccount, new List<AMS_Accreditation_Contact__c>());

					for(AMS_Accreditation_Contact__c trainedStaffToRemove: allTrainedStaff) {						
						if(trainedStaffToRemove.Type_Of_Certificate__c == 'DGR' && trainedStaffToRemove.Valid_until__c != null){
							//trainedStaffDGR.put(tsAccount, new List<AMS_Accreditation_Contact__c>());
							trainedStaffDGR.get(tsAccount).add(trainedStaffToRemove);
						}
					}

					system.debug('Trained staff to remove: '+ trainedStaffDGR);
					system.debug('All Trained staff: '+ allTrainedStaff);

					checkCertifications(trainedStaffDGR.get(oscar.Account__c), locationType, true, locationClass, countryCode, minDgrHO, minDgrBR, cassNumber);
				}

			}
		}
	}

	private static void checkCertifications(List<AMS_Accreditation_Contact__c> trainedStaff, String accountLocationType, boolean handling, String locationClass, String countryCode, Integer minimumHODgrRequirements, Integer minimumBRDgrRequirements, Integer cassNumber){

		Integer numberDGR = 0;
		Integer numberDGA = 0;

		if(trainedStaff != null)
			for(AMS_Accreditation_Contact__c tStaff :trainedStaff){
				if(tStaff.Type_Of_Certificate__c == AMS_Utils.CERT_DGR)
					numberDGR++;
				else if(tStaff.Type_Of_Certificate__c == AMS_Utils.CERT_DGA)
					numberDGA++;
		}

		System.debug('OSCARTriggerHandler -> checkCertifications: number of DGR ' + numberDGR);
		System.debug('OSCARTriggerHandler -> checkCertifications: number of DGA ' + numberDGA);

		System.debug('CHECK VALUES countryCode' + countryCode + ' locationClass ' + locationClass + ' accountLocationType ' + accountLocationType + ' cassNumber ' + cassNumber);

		if(handling){
			if(countryCode == 'CN' && locationClass == 'C' && numberDGR < 3){
				throw new AMSException('##This agency must have at least 3 DGR that are not expired.##');

			}else if(countryCode == 'IN' && locationClass == 'C' && accountLocationType == AMS_Utils.BR && cassNumber >= 900 && cassNumber <= 999){
				 //India has this particular exception to the normal behaviour, no check is to be done
			}else if(locationClass == 'C'){
				if(accountLocationType == AMS_Utils.HO && numberDGR < 2 )
					throw new AMSException('##An HO Agency handling dangerous goods must have at least 2 DGR that are not expired.##');
				else if(accountLocationType == AMS_Utils.BR && numberDGR < 1)
					throw new AMSException('##A BR Agency handling dangerous goods must have at least 1 DGR that is not expired.##');
			}else if(locationClass == 'R'){
				system.debug('validateCertificates -> locationClass == R');
				//Only America is using DGR for Cass associate.
				if(accountLocationType == AMS_Utils.HO && numberDGR/* + numberDGA*/ < minimumHODgrRequirements )
					throw new AMSException('##This agency must have at least ' + minimumHODgrRequirements + ' DGR that are not expired.##');
				else if(accountLocationType == AMS_Utils.BR && numberDGR/* + numberDGA*/ < minimumBRDgrRequirements){
					throw new AMSException('##This agency must have at least ' + minimumBRDgrRequirements + ' DGR that is not expired.##');
				}
			}
		}
		else{
			if(locationClass == 'C'){
				if(accountLocationType == AMS_Utils.HO && numberDGA < 2 )
					throw new AMSException('##An HO Agency not handling dangerous goods must have at least 2 DGA that are not expired.##');
				else if(accountLocationType == AMS_Utils.BR && numberDGA < 1)
					throw new AMSException('##A BR Agency not handling dangerous goods must have at least 1 DGA that is not expired.##');
			}
			/*if( numberDGA < 1 )
				throw new AMSException('##An Agency not handling dangerous goods must have at least 1 DGA that is not expired.##');*/
		}

	}

	private static void updateOSCARAppointments(){

		List<AMS_OSCAR__c> oscarsToProcess = new List<AMS_OSCAR__c>();
		Set<Id> oscarsToProcessIds = new Set<Id>();
		Map<Id, AMS_OSCAR__c> oldMap = (Map<Id,AMS_OSCAR__c>) Trigger.oldMap;

		for(AMS_OSCAR__c oscar : (List<AMS_OSCAR__c>)Trigger.New){
			if( AMS_Utils.isProcessUsingAppointments(oscar) ){
				oscarsToProcess.add(oscar);
				oscarsToProcessIds.add(oscar.Id);
			}
		}

		if(!oscarsToProcess.isEmpty()){

			List<AMS_Inspection__c> allInspections = new List<AMS_Inspection__c>([SELECT Id, Account__c,OSCAR__c,OSCAR__r.Account__c, Date_Organisation_Status_attained__c,Last_synchronization__c,Accreditation_Endorsement_Status_code__c FROM AMS_Inspection__c WHERE OSCAR__c IN :oscarsToProcessIds]);

			Map<Id, List<AMS_Inspection__c>> inspectionsPerOSCAR = new Map<Id, List<AMS_Inspection__c>>();

			//get all inspections per oscar
			for(AMS_Inspection__c insp: allInspections){
				if(!inspectionsPerOSCAR.containsKey(insp.Oscar__c))
					inspectionsPerOSCAR.put(insp.Oscar__c, new List<AMS_Inspection__c>());

				inspectionsPerOSCAR.get(insp.Oscar__c).add(insp);
			}

			List<AMS_Inspection__c> allInspectionsToUpdate = new List<AMS_Inspection__c>();

			for(AMS_OSCAR__c oscar : oscarsToProcess){
				AMS_OSCAR__c oldOSCAR = oldMap.get(oscar.Id);
				if ((oldOSCAR.STEP1__c <> AMS_Utils.PASSED && oscar.STEP1__c == AMS_Utils.PASSED)||
					(oldOSCAR.STEP10__c <> AMS_Utils.PASSED && oscar.STEP10__c == AMS_Utils.PASSED))
				{
					allInspectionsToUpdate.addAll(AMS_Utils.modifyInspectionStatus(inspectionsPerOSCAR.get(oscar.Id), '9'));
				}
				if ((oldOSCAR.STEP3__c <> AMS_Utils.PASSED && oscar.STEP3__c == AMS_Utils.PASSED) ||
					(oldOSCAR.STEP18__c <> AMS_Utils.PASSED && oscar.STEP18__c == AMS_Utils.PASSED) ||
					(oldOSCAR.STEP4__c <> AMS_Utils.PASSED && oscar.STEP4__c == AMS_Utils.PASSED))
				{
					allInspectionsToUpdate.addAll(AMS_Utils.modifyInspectionStatus(inspectionsPerOSCAR.get(oscar.Id), '0'));
				}
			}

			//update all modified inspections
			if(!allInspectionsToUpdate.isEmpty())
				update allInspectionsToUpdate;

		}
	}

	private static void handleVRProcess() {

		List<AMS_OSCAR__c> triggerNew = (List<AMS_OSCAR__c>)Trigger.new;
        Map<Id, AMS_OSCAR__c> oldMap = (Map<Id, AMS_OSCAR__c>)Trigger.oldMap;

        Id volRelRT = Schema.SObjectType.AMS_OSCAR__c.getRecordTypeInfosByName().get('VOLUNTARY RELINQUISHMENT').getRecordTypeId();
		List<AMS_Oscar__c> oscars = filterOSCARbyRT(volRelRT, triggerNew);

		if(oscars.isEmpty()) return;

		Set<Id> accountIds = new Set<Id>();
		Set<Id> oscarOnlineAccredIds = new Set<Id>();
		Map<Id, Set<Id>> accountsInvolved = new Map<Id, Set<Id>>();

		for (AMS_OSCAR__c oscar : oscars) {
			accountIds.add(oscar.Account__c);
			accountIds.add(oscar.AMS_Target_Agency__c);
			oscarOnlineAccredIds.add(oscar.AMS_Online_Accreditation__c);
			accountsInvolved.put(oscar.Id, new Set<Id>{oscar.Account__c});
		}

		//find all agencies involved
		//DTULLO: Added Record Type
		for (AMS_Process_Detail__c pd : [SELECT Id, Account__c, OSCAR__c FROM AMS_Process_Detail__c WHERE OSCAR__c IN :oscars AND Account__c != '' and RecordType.Developername = 'Agency_Involved']) {

			accountsInvolved.get(pd.OSCAR__c).add(pd.Account__c);
		}

		//get staging area infos
		Map<Id, AMS_Pax_Accreditation_Form__c> onlineAccreditations = getAccreditations(oscarOnlineAccredIds);

		//need to get all the hierarchy relationships for the account related to each OSCAR
		Map<Id, List<AMS_Agencies_relationhip__c>> relationshipMap = AMS_HierarchyHelper.getAccountsHierarchies(accountIds);

		for (List<AMS_Agencies_relationhip__c> hierarchyRelations : relationshipMap.values()) {
			for (AMS_Agencies_relationhip__c relationship : hierarchyRelations) {

				accountIds.add(relationship.Parent_Account__c);
				accountIds.add(relationship.Child_Account__c);
			}
		}

		//get account infos
		Map<Id, Account> accounts = getAccounts(accountIds);

		//map accountId -> active change code
		Map<Id, Agency_Applied_Change_code__c> accountsChangeCode = new Map<Id, Agency_Applied_Change_code__c>();
		for (Agency_Applied_Change_code__c changeCode : [SELECT Id, Account__c, Reason_Code__c, Reason_Description__c, Bulletin_Information__c FROM Agency_Applied_Change_code__c WHERE Account__c IN :accountIds AND Active__c = true]){
			accountsChangeCode.put(changeCode.Account__c, changeCode);
	}


		List<AMS_Utils.Container> changesContainer = new List<AMS_Utils.Container>();
		List<AMS_Oscar__c> oscarsToCheckHierarchy = new List<AMS_Oscar__c>();

		for(AMS_OSCAR__c updatedOSCAR : oscars){
			AMS_OSCAR__c oldOSCAR = oldMap.get(updatedOSCAR.Id);


			if (oldOSCAR.Form_Effective_date__c != updatedOscar.Form_Effective_date__c
			    || oldOSCAR.Financial_Security_expiry_date__c != updatedOscar.Financial_Security_expiry_date__c) {

				Date formDate = updatedOscar.Form_Effective_date__c;
				Date fsDate = updatedOscar.Financial_Security_expiry_date__c;

			    updatedOSCAR.Change_effective_as_of__c = formDate;

				if((fsDate != null && formDate == null) || fsDate < formDate) updatedOSCAR.Change_effective_as_of__c = fsDate;
				//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the first chech is necessary because the second check fails if formDate is null
			}

			if (oldOSCAR.STEP6__c != AMS_Utils.PASSED && updatedOscar.STEP6__c == AMS_Utils.PASSED){

				oscarsToCheckHierarchy.add(updatedOSCAR);

			    if(updatedOSCAR.Change_effective_as_of__c > Date.today()) updatedOSCAR.Status__c = 'Accepted_Future Date';
			    else updatedOSCAR.Status__c = 'On Hold_Internal';

			    if(updatedOSCAR.Process__c == AMS_Utils.VOLRELINQUISH) changesContainer.add(AMS_ChangeCodesHelper.generateVRChangeCode(AMS_Utils.SANITYCHECK, updatedOSCAR, accountsInvolved.get(updatedOSCAR.Id), accounts, accountsChangeCode));
			}

			if (oldOSCAR.STEP30__c != AMS_Utils.PASSED && updatedOSCAR.STEP30__c == AMS_Utils.PASSED) {
			    updatedOSCAR.Status__c = 'Accepted_Future Date';

			    Set<String> nextMonthLocations = new Set<String>{'P', 'D'};
			    Date terminationDate = nextMonthLocations.contains(updatedOSCAR.Location_Class__c) ? AMS_Utils.lastDayOfMonth(Date.today().addMonths(1)) : Date.today().addDays(15);
			    updatedOSCAR.Termination_date__c = BusinessHours.nextStartDate(updatedOSCAR.BusinessHours__c, DateTime.newInstance(terminationDate, System.now().time())).date();

			    if(updatedOSCAR.Process__c == AMS_Utils.VOLRELINQUISH){
			    	updatedOSCAR.Process_Start_Date__c = updatedOSCAR.Termination_Date__c;
			    	changesContainer.add(AMS_ChangeCodesHelper.generateVRChangeCode(AMS_Utils.SUSPENSION, updatedOSCAR, accountsInvolved.get(updatedOSCAR.Id), accounts, accountsChangeCode));
			    }
			}

			if (oldOSCAR.STEP31__c != AMS_Utils.PASSED && updatedOSCAR.STEP31__c == AMS_Utils.PASSED) {
				changesContainer.add(AMS_ChangeCodesHelper.generateVRChangeCode(AMS_Utils.TERMINATION, updatedOSCAR, accountsInvolved.get(updatedOSCAR.Id), accounts, accountsChangeCode));
			}

			if (oldOSCAR.STEP32__c != AMS_Utils.PASSED && updatedOSCAR.STEP32__c == AMS_Utils.PASSED) {
				if(
					(updatedOSCAR.Process__c == AMS_UTils.VOLRELINQUISH && updatedOscar.STEP6__c != AMS_Utils.PASSED) || 
					(updatedOSCAR.Process__c == AMS_UTils.VOLRELINQUISH_CA && updatedOSCAR.STEP31__c != AMS_Utils.PASSED)
				) updatedOSCAR.addError('Process can only be withdrawn after the process started');
				
				changesContainer.add(AMS_ChangeCodesHelper.generateVRChangeCode(AMS_Utils.WITHDRAWAL, updatedOSCAR, accountsInvolved.get(updatedOSCAR.Id), accounts, accountsChangeCode));
			}
		}

		if(!oscarsToCheckHierarchy.isEmpty()){
			Map<Id, Boolean> isChildrenSelected = AMS_HierarchyHelper.isAllChildrenSelected(oscarsToCheckHierarchy, relationshipMap, accountsInvolved);
			for(AMS_Oscar__c oscar : oscarsToCheckHierarchy) if(!isChildrenSelected.get(oscar.Id)) oscar.addError('For Voluntary Relinquishment, the analyst cannot select a parent account without its children');
		}

		//insert the change codes
		if (changesContainer.size() > 0) {

			List<Account> accsToUpdateFromCC = new List<Account>();
			List<AMS_OSCAR_JSON.ChangeCode> changeCodes = new List<AMS_OSCAR_JSON.ChangeCode>();
			List<Account> accts = new List<Account>();
			List<AMS_OSCAR__c> theoscars = new List<AMS_OSCAR__c>();

			//merge everything
			for (AMS_Utils.Container c : changesContainer) {
				changeCodes.addAll(c.changeCodes);
				accts.addAll(c.accts);

				theoscars.addAll(c.oscars);
			}

			AMS_ChangeCodesHelper.createAAChangeCodes( changeCodes, theoscars, accts, true);
		}

	}

	//*************************************
	//********** access methods ***********
	//*************************************

	public static Map<String, Schema.SObjectField> getOSCARFieldMap() {

		return Schema.getGlobalDescribe().get('AMS_OSCAR__c').getDescribe().fields.getMap();

	}

	public static List<String> getOSCARStepsApiName() {

		List<String> oscarSteps = new List<String>();

		for (String fieldApiName : getOSCARFieldMap().keySet()) {
			if (fieldApiName.startsWithIgnoreCase('STEP'))
				oscarSteps.add(fieldApiName);

		}

		return oscarSteps;
	}

	private static Map<Id, Account> getAccounts(Set<Id> accountIds) {
		return new Map<Id, Account>([SELECT Id, ParentId, Parent.Location_Type__c,Parent.IATACode__c, Status__c, Name, IATACode__c, Company_Type__c, Short_Name__c, TradeName__c, License_Number__c, VAT_Number__c, GDS__c, Operation__c,
		        BillingCountry, BillingStreet, BillingPostalCode, BillingState, BillingCity, IATA_ISO_Country__c, Iso_State__c, ShippingCountry, Is_Branch_Abroad__c,
		        ShippingStreet, ShippingPostalCode, ShippingState, ShippingCity, Email__c, Website, Phone, Fax, In_a_Airport__c, Abbreviated_name__c, Abbreviated_address__c,
		        Remittance_frequency__c, Solicitation_Flag__c, VAT_Number_2__c, CASS_Number__c, Location_Class__c, Location_Type__c, Mobile__c, Is_your_firm_handling_Dangerous_Goods__c,
		        Due_Diligence_Status__c, IATA_ISO_Shipping_State__r.Name, ISO_State__r.Name,IATA_ISO_Country__r.Name,IATA_ISO_Shipping_Country__c,IATA_ISO_Shipping_Country__r.Name,IATA_ISO_Billing_State__c,IATA_ISO_Billing_State__r.Name
		         FROM Account WHERE Id IN :accountIds]);
	}

	private static Map<Id, AMS_Pax_Accreditation_Form__c> getAccreditations(Set<Id> oscarOnlineAccredIds){
		return new Map<Id, AMS_Pax_Accreditation_Form__c>([SELECT Account_Name__c, IATACode__c, ISSP_AMS_Legal_Status__c, Short_Name__c, Trade_Name__c, ISSP_AMS_License_No__c, ISSP_AMS_VAT_number__c,
		        ISSP_AMS_GDS_with_signed_contract__c, Operation__c, Branch_Office_Country__r.Name, Branch_Office_Country__r.Due_diligence_mandatory__c, Branch_Office_Street_name_number__c, Branch_Office_Postal_code__c,
		        Billing_State__c, Branch_Office_City__c, ISO_Country__c, IATA_ISO_State__c, Shipping_Country__c, Shipping_Street__c, Shipping_Postal_Code__c,
		        Shipping_State__c, Shipping_City__c, Branch_Office_Email__c, Website__c, Branch_Office_Phone__c, Branch_Office_FAX__c, ISSP_AMS_Premises_located_at_airport__c,
		        Abbreviated_name__c, Abbreviated_address__c, Remittance_frequency__c, Solicitation_Flag__c, VAT_Number_2__c, CASS_Number__c, Location_Class__c, Location_Type__c, Mobile__c, Is_your_firm_handling_Dangerous_Goods__c,
		        Shipping_ISO_Country__c, Shipping_ISO_State__c, Shipping_ISO_Country__r.Name, Shipping_ISO_State__r.Name, IATA_ISO_State__r.Name, IATA_ISO_State__r.Valid_for_Address__c   
		        FROM AMS_Pax_Accreditation_Form__c
		        WHERE Id IN :oscarOnlineAccredIds]);
	}

	public static List<AMS_OSCAR__c> filterOSCARbyRT(Id recTypeId, List<AMS_OSCAR__c> oscars) {

		List<AMS_OSCAR__c> changeOscars = new List<AMS_OSCAR__c>();
		for (AMS_OSCAR__c oscar : oscars) {
			if (oscar.recordTypeID == recTypeId)
				changeOscars.add(oscar);
		}

		return changeOscars;
	}


	public static void sendEmailAlert(Id oscarId, String oscarCommCaseId, boolean wasApproved) {

		if(oscarCommCaseId != null){

	        OrgWideEmailAddress[] owea = [select Id from OrgWideEmailAddress where Address = 'agencymanagement@iata.org'];

			AMS_AgencyRegulationAutoRenewal.sendEmailAlert(fetchContactInfoFromCase(oscarCommCaseId), oscarId, ANGemailTemplates(wasApproved), oscarCommCaseId, owea[0], false);

		}else{

			System.debug('Could not find the case Id to send the email.');
		
		}

	}


	private static List<Contact> fetchContactInfoFromCase(String oscarCommCaseId){

		 return [Select Id, Name, Email, Preferred_Language__c, BSP_CASS_Payment_contact__c, Financial_Assessment_Contact__c from Contact where Id in (select ContactId from Case where Id = :oscarCommCaseId )];

	}
	
	private static Map<String, Id> ANGemailTemplates(boolean wasApproved){

        Map<String, Id> multilangTemplates = new Map<String, Id>();

        String templateId = 'ANG_New_HE_Accreditation_Decision';

        String auxStrDecision = wasApproved ? templateId+'_APP' : templateId+'_DIS';

        //Get the templates for NG accreditation outcoume
        List<EmailTemplate> etNG = Database.query('SELECT Id, DeveloperName, HtmlValue, Subject FROM EmailTemplate WHERE DeveloperName LIKE \'' + auxStrDecision + '%\'' );

        Map<String, EmailTemplate> countryTemplates = new Map<String, EmailTemplate>();
        for(EmailTemplate et: etNG){
            if(!countryTemplates.containsKey(et.DeveloperName))
                countryTemplates.put(et.DeveloperName, et);
        }

        //map template Ids with their respective language
        List<Schema.Picklistentry> prefLanguages = Contact.getSObjectType().getDescribe().fields.getMap().get('Preferred_Language__c').getDescribe().getPickListValues();
        
        for(Schema.Picklistentry pe: prefLanguages){
            EmailTemplate langTemplate = countryTemplates.get(auxStrDecision+ '_' + pe.getValue());
            if(langTemplate == null) //English is default and must exist in the system
                countryTemplates.get(auxStrDecision+'_English');
                if(langTemplate != null)
		            multilangTemplates.put(pe.getValue(), langTemplate.Id);
        }

        //this should never happen unless picklist values are deleted form the Contact Preferred_Language__c
        if(multilangTemplates.isEmpty())
            multilangTemplates.put('English', countryTemplates.get(auxStrDecision + '_English').Id);

        return multilangTemplates;

    }
 
	public static Map<Id,AMS_HierarchyHelper.AccountStruct> getAccountsInfoBeforeChanges(Map<Id,Account> accountsMap) {


		Map<Id,AMS_HierarchyHelper.AccountStruct> locationTypeAccountID = new Map<Id,AMS_HierarchyHelper.AccountStruct> ();

		for(Id accId : accountsMap.keySet())
		{
			locationTypeAccountID.put(accId,new AMS_HierarchyHelper.AccountStruct(accountsMap.get(accId).Parent.IATACode__c,accountsMap.get(accId).Location_Type__c));

			system.debug('DDD1 Acct ID: ' + accId);

			system.debug('DDD1 Acct Old Location Type: ' + accountsMap.get(accId).Location_Type__c );

			system.debug('DDD1 Acct Old Parent IATA Code: ' + accountsMap.get(accId).Parent.IATACode__c );


		}

		return locationTypeAccountID;
	}

	private Class AccountStruct{
		
	    private String parentIATACode;
	    private String locationType;

	    private AccountStruct(String parentIATACode, String locationType) {
	        this.parentIATACode = parentIATACode;
	        this.locationType = locationType;
	    }
	}

	public static void checkOwnershipOnProcess(List<AMS_OSCAR__c> oscars, Map<Id,AMS_OSCAR__c> oldMap){

		Map<Id, Integer> contacts = getAccreditationContacts(oscars);

		ID newNGRT = Schema.SObjectType.AMS_OSCAR__c.getRecordTypeInfosByName().get('NG New HE').getRecordTypeId();
		
		Map<Id, Integer> allPercentages = getAllOWnersPercentage(oscars);

		For(AMS_OSCAR__c oscar: oscars){

			if(oldMap.get(oscar.Id).STEP6__c <> AMS_Utils.PASSED && oscar.STEP6__c == AMS_Utils.PASSED && oscar.RecordTypeId == newNGRT){

				if(contacts.get(oscar.AMS_Online_Accreditation__c) > 0)
					continue;
				else	
					if(!validate100Ownership(oscar,allPercentages))
						oscar.addError('Agency does not have 100% ownership. Please add the owners to the agency before passing the Sanity Check.');

			}
		}

	}

	public static Map<Id, Integer> getAccreditationContacts(List<AMS_Oscar__c> oscars){

		Set<Id> onlineForms = new Set<Id>();

		For(AMS_OSCAR__c oscar : oscars)
			onlineForms.add(oscar.AMS_Online_Accreditation__c);

		List<AggregateResult> sumPercentageAR = [select AMS_Pax_Accreditation_Form__r.Id, count(Id) numberOfContacts from AMS_Accreditation_Contact__c  where AMS_Pax_Accreditation_Form__c in :onlineForms group by AMS_Pax_Accreditation_Form__r.Id];

		Map<Id,Integer> toReturn = new Map<Id,Integer>();

		for(AggregateResult ar: sumPercentageAR){
			toReturn.put((Id)ar.get('Id'), Integer.valueOf(ar.get('numberOfContacts')));
		}

		return toReturn;

	}

	public static Map<Id, Integer> getAllOWnersPercentage(List<AMS_Oscar__c> oscars){

		Set<Id> accounts = new Set<Id>();

		For(AMS_OSCAR__c oscar : oscars)
			accounts.add(oscar.Account__c);

		List<AggregateResult> sumPercentageAR = [select Account__r.Id, SUM(Percentage__c) percentage from AMS_Account_Role__c  where Account__c in :accounts and Active__c = true group by Account__r.Id];

		Map<Id,Integer> toReturn = new Map<Id,Integer>();

		for(AggregateResult ar: sumPercentageAR){
			toReturn.put((Id)ar.get('Id'), Integer.valueOf(ar.get('percentage')));
		}

		return toReturn;

	}

	public static boolean validate100Ownership(AMS_OSCAR__c oscar,  Map<Id, Integer> percentages){

		return percentages.get(oscar.Account__c) == 100;

	}

}