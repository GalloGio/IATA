public class EF_BillingAgreementHandler 
{
    private static boolean run = true;   
    
    // Submits E&F Billing Agreements for approval processing if the helper field is set to TRUE
    public static void startApprovalProcesses(List<EF_Billing_Agreement__c> baList)
    {
        for(EF_Billing_Agreement__c ba : baList)
        {
            if(ba.Require_Approval__c)
            {
                EF_BaContractApprovalHelper.submitForApproval(ba.Id, UserInfo.getUserId(), '');
            }
        }
    }

    // Identifies and handles both Approved, Rejected and Recalled approvals 
    public static void handleApprovedAndRejectedApprovals(List<EF_Billing_Agreement__c> newValues, Map<Id, EF_Billing_Agreement__c> oldValues)
    {
        // Find the Custom Setting values for "Approval Required" fields and...
        List<EF_Approve_Fields__c> fieldList = [select id, name, Billing_Agreement_Fields__c from EF_Approve_Fields__c where Name = 'BillingAgreement'];
        List<String> fields = fieldList.get(0).Billing_Agreement_Fields__c.split(',');
        List<EF_Billing_Agreement__c> approvedList = EF_BaContractApprovalHelper.identifyApprovedBillingAgreements(newValues, oldValues);
        List<EF_Billing_Agreement__c> rejectedList = EF_BaContractApprovalHelper.identifyRejectedOrRecalledBillingAgreements(newValues, oldValues);
        if(approvedList.size() > 0)
        {
            // If approval occurred, copies the approved values from temporary storage onto the record itself
            EF_BaContractApprovalHelper.copyValuesFromTempStorageOnBaApproval(approvedList, fields);
        }
        if(rejectedList.size() > 0)
        {
            // Or if rejected or recalled, simply ignore the changes and get rid of the temp storage record
            EF_BaContractApprovalHelper.removeTempStorageRecordOnBaRejection(rejectedList);
        }
    }

    // Queries for any Accounts that do only allow Billing Agreements to be updated with approval
    public static void handleWithApprovalAccountUpdates(Map<Id, EF_Billing_Agreement__c> newAgreements, Map<Id, EF_Billing_Agreement__c> oldAgreements)
    {
        Set<Id> accountIds = new Set<Id>();
        for(EF_Billing_Agreement__c ba : newAgreements.values())
        {
            // add both Client and Customer (Airline) into the Set, so that both will be queried for
            accountIds.add(ba.Client__c);
            accountIds.add(ba.Airline__c);
        }

        Map<Id, Account> accountsInvolved = new Map<Id, Account>([select id, EF_Allow_Billing_Agreements__c from Account where Id in :accountIds and EF_Allow_Billing_Agreements__c = 'Allowed with Approval']);
        if(accountsInvolved.size() > 0)
        {
            List<EF_Billing_Agreement__c> agreementsToApprove = new List<EF_Billing_Agreement__c>();
            for(EF_Billing_Agreement__c allAgreements : newAgreements.values())
            {
                if(accountsInvolved.get(allAgreements.Client__c) != null)
                    agreementsToApprove.add(allAgreements);
                else if(accountsInvolved.get(allAgreements.Airline__c) != null)
                    agreementsToApprove.add(allAgreements);
            }

            // Create a list of EF Approval records that will be stored in the system to contain the UPDATED versions of Billing Agreements
            List<EF_Approval__c> approvalStorageList = new List<EF_Approval__c>();
            // Get the list of fields that require Approval from Custom Settings and place them in a List
            List<EF_Approve_Fields__c> fieldList = [select id, name, Billing_Agreement_Fields__c from EF_Approve_Fields__c where Name = 'BillingAgreement'];
            List<String> fields = fieldList.get(0).Billing_Agreement_Fields__c.split(',');

            // If there are any Billing Agreements that require approval, start the process to temporarily store them into another object
            for(EF_Billing_Agreement__c ba : agreementsToApprove)
            {
                if(EF_BaContractApprovalHelper.identifyBillingAgreementChanges(ba, oldAgreements.get(ba.Id), fields))
                {
                    EF_Approval__c approval = EF_BaContractApprovalHelper.fillTemporaryApprovalStorage(new EF_Approval__c(), ba, fields);
                    ba.Require_Approval__c = true;
                    approvalStorageList.add(approval);
                    EF_BaContractApprovalHelper.rollbackPreviousValues(ba, oldAgreements.get(ba.Id), fields);
                }
            }

            if(approvalStorageList.size() > 0)
            {
                insert approvalStorageList;
            }
        }
    }

    // For after insert trigger to find out if any of the attached Accounts is set to "Allow Billing Agreements with Approval"
    public static Set<Id> findIdsOfWithApprovalBillingAgreements(List<EF_Billing_Agreement__c> agreementList)
    {
        Set<Id> accountIds = new Set<Id>();
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            accountIds.add(ba.Client__c);
            accountIds.add(ba.Airline__c);
        }

        Set<Id> withApprovalIds = new Set<Id>();
        Map<Id, Account> accountsInvolved = new Map<Id, Account>([select id, EF_Allow_Billing_Agreements__c from Account where Id in :accountIds and EF_Allow_Billing_Agreements__c = 'Allowed with Approval']);
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            withApprovalIds.add(ba.Id);
        }
        return withApprovalIds;
    }

    // Queries for any Accounts that do only allow Billing Agreements to be created with approval
    public static void handleWithApprovalAccountInserts(List<EF_Billing_Agreement__c> agreementList)
    {
        Set<Id> accountIds = new Set<Id>();
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            // add both Client and Customer (Airline) into the Set, so that both will be queried for
            accountIds.add(ba.Client__c);
            accountIds.add(ba.Airline__c);
        }

        // Find if any of the related accounts doesn't allow billing agreements to be created without approval and force-start an approval process
        Map<Id, Account> accountsInvolved = new Map<Id, Account>([select id, EF_Allow_Billing_Agreements__c from Account where Id in :accountIds and EF_Allow_Billing_Agreements__c = 'Allowed with Approval']);
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            if(accountsInvolved.get(ba.Client__c) != null || accountsInvolved.get(ba.Airline__c) != null)
            {
                ba.Require_Approval__c = true;
                ba.Status__c = 'Inactive';
            }
        }
    }

    // Queries for any Accounts that do not allow Billing Agreements and displays an error message to the User.
    public static void preventAgreementCreationForNotAllowed(List<EF_Billing_Agreement__c> agreementList)
    {
        String errorMessage = Label.EF_Account_Disallow_BA;
        Set<Id> accountIds = new Set<Id>();
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            // add both Client and Customer (Airline) into the Set, so that both will be queried for
            accountIds.add(ba.Client__c);
            accountIds.add(ba.Airline__c);
        }

        // Find if any of the related accounts doesn't allow billing agreements to be created and throw an error
        Map<Id, Account> accountsInvolved = new Map<Id, Account>([select id, EF_Allow_Billing_Agreements__c from Account where Id in :accountIds and EF_Allow_Billing_Agreements__c = 'Not Allowed']);
        for(EF_Billing_Agreement__c ba : agreementList)
        {
            if(accountsInvolved.containsKey(ba.Client__c))
            {
                ba.Client__c.addError(errorMessage);
            }
            else if(accountsInvolved.containsKey(ba.Airline__c))
            {
                ba.Airline__c.addError(errorMessage);
            }
        }
    }

    //checks if location chosen has been set in Contract Location Currency.
    public static void checkLocationCurrency (List<EF_Billing_Agreement__c> relationshipList){

        //check if relationship records have location.
        List <EF_Billing_Agreement__c> relWithLocation = new List <EF_Billing_Agreement__c>();

        for(EF_Billing_Agreement__c rel: relationshipList){
            if(rel.EF_Location_ID__c!=null){
                relWithLocation.add(rel);
            }
        }

        Set <Id> contractIdSet = new Set <Id>();

        if(!relWithLocation.isEmpty()){

            for(EF_Billing_Agreement__c r: relWithLocation){
                contractIdSet.add(r.Contract__c);
            }

            Map <Id, Contract> contractMap = new Map <Id, Contract>([Select Id, (Select Id, Location_ID__c, Location_ID__r.Name, Contract__c, EF_Billing_Currency__c from EF_Locations_Currencies__r),
            (select Id, EF_Location_ID__c, EF_Location_ID__r.Name, Contract__c, Billing_Currency__c from EF_Relationships__r) from Contract where Id in: contractIdSet]);
            
            //create a map in which we store all the locations present in contract
            Map <Id, EF_Location_Currency__c> mapLocationsInLocationCurrency = new Map <Id, EF_Location_Currency__c> ();
            
            for(Contract c: contractMap.values()){
                for(EF_Location_Currency__c lc: c.EF_Locations_Currencies__r){
                    mapLocationsInLocationCurrency.put(lc.Location_ID__c, lc);
                }
            }

            //create a map in which we store all the billing agreements already present in contract
            Map <Id, EF_Billing_Agreement__c> mapRelationshipsInContract = new Map <Id, EF_Billing_Agreement__c> ();
            for(Contract c: contractMap.values()){
                for(EF_Billing_Agreement__c r: c.EF_Relationships__r){
                    mapRelationshipsInContract.put(r.EF_Location_ID__c, r);
                }
            }
           
            //check if location chosen in relationship is present in Contract Location Currencies
            for(EF_Billing_Agreement__c r: relWithLocation){
                
                if(mapLocationsInLocationCurrency.isEmpty() && r.EF_Location_ID__c!=null){
                   r.EF_Location_ID__c.addError('Please set before location currencies on contract.');
                }else{
                    if(!mapLocationsInLocationCurrency.containsKey(r.EF_Location_ID__c)){
                        r.EF_Location_ID__c.addError('Location chosen is not allowed. It has not been defined in Contract as a valid location.');
                    }else{
                        if(mapRelationshipsInContract.containsKey(r.EF_Location_ID__c)){

                           //LDC 08222016 This case should not be blocked, r.EF_Location_ID__c.addError('Location chosen has already been set for another relationship');
                            
                        }else{
                            for(EF_Location_Currency__c lc: contractMap.get(r.Contract__c).EF_Locations_Currencies__r){
                                System.debug('#### REL loc Id ' + r.EF_Location_ID__c + r.EF_Location_ID__r.Name + ' --- location Currency ' + lc.Location_ID__c + lc.Location_ID__r.Name);
                                if(r.EF_Location_ID__c== lc.Location_ID__c){
                                    // set currency in relationship as the one defined on the locationCurrency
                                    r.Billing_Currency__c = lc.EF_Billing_Currency__c;
                                }
                            }
                        }
                    }
                }
            }
        }// end if relationship has location
    }
    
    //checks if currencies chosen has been set in Contract Currencies.
    public static void checkCurrencyFromContract (List<EF_Billing_Agreement__c> relationshipList, Map<Id,EF_Billing_Agreement__c> relationshipOldMap){
        
        String errorMessage = Label.EF_Currency_Not_In_Contract_Error;
        List<EF_Billing_Agreement__c> workdata = new List<EF_Billing_Agreement__c>();
        Set<Id> contractIdSet = new Set<Id>();

        for (EF_Billing_Agreement__c rel : relationshipList) {
            
            EF_Billing_Agreement__c oldRel = (relationshipOldMap != null && relationshipOldMap.containsKey(rel.Id) ? relationshipOldMap.get(rel.Id) : new EF_Billing_Agreement__c());
            
            if ((rel.Data_Currency__c != null && rel.Data_Currency__c != oldRel.Data_Currency__c) ||
                (rel.Payment_Currency__c != null && rel.Payment_Currency__c != oldRel.Payment_Currency__c)) {
                
                workdata.add(rel);
                contractIdSet.add(rel.Contract__c);
            }
        }
        
        if (workdata.size() > 0) {
            
            Map <Id, Contract> contractMap = new Map <Id, Contract>([Select Id, EF_Data_Currency__c, EF_Payment_Currency__c from Contract where Id in: contractIdSet]);
            Contract cont;
            Set<String> values;
            
            for (EF_Billing_Agreement__c rel : workdata) {
                
                cont = contractMap.get(rel.Contract__c);
                
                // Data_Currency__c validation
                if (rel.Data_Currency__c != null) {
                    
                    if (cont.EF_Data_Currency__c != null) {
                        
                        values = new Set<String>(cont.EF_Data_Currency__c.split(';'));
                    } else {
                        
                        values = new Set<String>();
                    }
                    
                    if (values.contains(rel.Data_Currency__c) == false) {
                        
                        rel.Data_Currency__c.addError(errorMessage);
                    }
                }
                
                values = null;
                
                // Payment_Currency__c validation
                if (rel.Payment_Currency__c != null) {
                    
                    if (cont.EF_Payment_Currency__c != null) {
                        
                        values = new Set<String>(cont.EF_Payment_Currency__c.split(';'));
                    } else {
                        
                        values = new Set<String>();
                    }
                    
                    if (values.contains(rel.Payment_Currency__c) == false) {
                        
                        rel.Payment_Currency__c.addError(errorMessage);
                    }   
                }
            }
        }
    }

    // helper method to stop Billing Agreement Trigger from running more than once per update
    public static boolean runOnce()
    {
        if(run)
        {
            run = false;
            return true;
        }
        else
        {
            return run;
        }
    }
    
    public static void setClientFromRelatedContract(List<EF_Billing_Agreement__c> agreementList) {

        Set <Id> contractIdSet = new Set <Id> ();
        for(EF_Billing_Agreement__c ba: agreementList){
            contractIdSet.add(ba.Contract__c);
        }

        Map<Id, Contract> contractMap = new Map<Id, Contract> ([select Id, AccountId from Contract where Id in: contractIdSet]);

        for(EF_Billing_Agreement__c ba : agreementList) {
            if(contractMap.containsKey(ba.Contract__c)){
                ba.Client__c = contractMap.get(ba.Contract__c).AccountId;
            }            

        }
    }
}